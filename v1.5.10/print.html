<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>ZKsync Solidity Compiler Toolchain Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="css/version-box.css">


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">ZKsync Solidity Compiler Toolchain Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="installing-the-zksync-solidity-compiler-toolchain"><a class="header" href="#installing-the-zksync-solidity-compiler-toolchain">Installing the ZKsync Solidity Compiler Toolchain</a></h1>
<p>To compile contracts for ZKsync, you need the ZKsync Solidity compiler toolchain.
It consists of two components:</p>
<ol>
<li>The main component: <a href="https://github.com/matter-labs/era-compiler-solidity/releases"><em>zksolc</em></a>.</li>
<li>The additional component: <a href="https://docs.soliditylang.org/en/latest"><em>solc</em></a>, which produces Solidity artifacts used by <em>zksolc</em>.</li>
</ol>
<blockquote>
<p>We are using our <a href="https://github.com/matter-labs/era-solidity">fork</a> of the upstream <em>solc</em> compiler.
The fork is necessary to support several ZKsync-specific features and workarounds.</p>
</blockquote>
<h2 id="system-requirements"><a class="header" href="#system-requirements">System Requirements</a></h2>
<p>It is recommended to have at least 4 GB of RAM to compile large projects. The compilation process is parallelized by default, so the number of threads used is
equal to the number of CPU cores.</p>
<blockquote>
<p>Large projects can consume a lot of RAM during compilation on machines with a high number of cores.
If you encounter memory issues, consider reducing the number of threads using the <code>--threads</code> option.</p>
</blockquote>
<p>The table below outlines the supported platforms and architectures:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: center">CPU/OS</th><th style="text-align: center">MacOS</th><th style="text-align: center">Linux</th><th style="text-align: center">Windows</th></tr></thead><tbody>
<tr><td style="text-align: center">x86_64</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td></tr>
<tr><td style="text-align: center">arm64</td><td style="text-align: center">✅</td><td style="text-align: center">✅</td><td style="text-align: center">❌</td></tr>
</tbody></table>
</div>
<blockquote>
<p>Please avoid using outdated distributions of operating systems, as they may lack the necessary dependencies or include outdated versions of them.
<em>zksolc</em> is only tested on recent versions of popular distributions, such as MacOS 11.0 and Windows 10.</p>
</blockquote>
<div class="warning">
<a href="https://musl.libc.org">musl</a>-based builds are deprecated, but they are still supported to preserve tooling compatibility.<br>
Starting from <b>zksolc</b> v1.5.3, we are shipping builds statically linked with <a href="https://www.gnu.org/software/libc/">the GNU C library</a>.
</div>
<h2 id="installing-zksolc"><a class="header" href="#installing-zksolc">Installing <em>zksolc</em></a></h2>
<p>You can install the ZKsync Solidity compiler toolchain using the following methods:</p>
<ol>
<li>Use Foundry, Hardhat, or other popular toolkits, so they will manage the compiler installation and their dependencies for you. See <a href="01-installation.html#ethereum-development-toolkits">Ethereum Development Toolkits</a>.</li>
<li>Download pre-built binaries of <a href="https://github.com/matter-labs/era-solidity/releases"><em>solc</em></a> and <a href="https://github.com/matter-labs/era-compiler-solidity/releases"><em>zksolc</em></a>. See <a href="01-installation.html#static-executables">Static Executables</a>.</li>
<li>Build <em>zksolc</em> from sources. See <a href="01-installation.html#building-from-source">Building from Source</a>.</li>
</ol>
<blockquote>
<p>For small projects, learning and research purposes, <em>zksolc</em> and <em>solc</em> executables without a toolkit are sufficient.</p>
</blockquote>
<h2 id="installing-solc"><a class="header" href="#installing-solc">Installing <em>solc</em></a></h2>
<p>Running <em>zksolc</em> requires the <a href="https://github.com/matter-labs/era-solidity/releases">fork of the Solidity compiler <em>solc</em></a> where <a href="./eravm/02-evm-assembly-translator.html#zksync-fork-of-solc">we fixed several issues</a> with lowering of EVM assembly to LLVM IR. The fork is called by <em>zksolc</em> as a child process. To point <em>zksolc</em> to the location of <em>solc</em>, use one of the following methods:</p>
<ol>
<li>
<p>Add the location of <em>solc</em> to the environment variable <code>PATH</code>.</p>
<p>For example, if you have downloaded <em>solc</em> to the directory <code>/home/username/opt</code>,
you can execute the following command, or append it to the configuration file of your shell:</p>
<pre><code class="language-shell">export PATH="/home/username/opt:${PATH}"
</code></pre>
</li>
<li>
<p>Alternatively, when you run <em>zksolc</em>, provide the full path to <em>solc</em> using the <code>--solc</code> option.</p>
<p>For example, if <code>solc</code> is located in your current working directory, you can point to it with this command:</p>
<pre><code class="language-shell">zksolc --solc './solc' --bin 'Greeter.sol'
</code></pre>
</li>
</ol>
<blockquote>
<p>The second option is more convenient if you are using different versions of <em>solc</em> for different projects.
The current version of <em>zksolc</em> supports <em>solc</em> versions from 0.4.12 to 0.8.28.</p>
</blockquote>
<h2 id="versioning"><a class="header" href="#versioning">Versioning</a></h2>
<p>The <em>zksolc</em> versioning scheme does not yet follow the <a href="https://semver.org">Semantic Versioning</a> specification. Instead, its major and minor versions match those of the EraVM protocol for which <em>zksolc</em> produces bytecode. The patch version is incremented with each release, regardless of whether breaking changes are introduced. Therefore, please consult the changelog before updating the compiler.</p>
<p>Versions of <a href="https://github.com/matter-labs/era-solidity/releases">our <em>solc</em> fork</a> consist of two <em>semver</em>-compatible parts:</p>
<ol>
<li>Original upstream version</li>
<li>ZKsync revision</li>
</ol>
<p>For instance, the latest revision of the latest version of <em>solc</em> is <code>0.8.28-1.0.1</code>. Here are the ZKsync revisions released by now:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Revision</th><th style="text-align: left">Features</th></tr></thead><tbody>
<tr><td style="text-align: left"><em>v1.0.0</em></td><td style="text-align: left">Fixed compatibility between EVM assembly and LLVM IR</td></tr>
<tr><td style="text-align: left"><em>v1.0.1</em></td><td style="text-align: left">Fixed a compiler crash with nested try-catch patterns</td></tr>
</tbody></table>
</div>
<blockquote>
<p>We recommend always using the latest version of <em>zksolc</em> and <em>solc</em> to benefit from the latest features and bug fixes.
Starting from <em>zksolc</em> v1.5.8, it is not possible to use the original <em>solc</em> with <em>zksolc</em> anymore.</p>
</blockquote>
<h2 id="ethereum-development-toolkits"><a class="header" href="#ethereum-development-toolkits">Ethereum Development Toolkits</a></h2>
<p>For large codebases, it is more convenient to use the ZKsync compiler toolchain via toolkits like Foundry and Hardhat.
These tools manage the compiler executables and their dependencies, and provide additional features like incremental compilation and caching.</p>
<p>The ZKsync toolchain is supported by the following toolkits:</p>
<ol>
<li><a href="https://docs.zksync.io/zksync-era/tooling/foundry/getting-started">Foundry</a></li>
<li><a href="https://docs.zksync.io/build/tooling/hardhat/guides/getting-started">Hardhat</a></li>
</ol>
<h2 id="static-executables"><a class="header" href="#static-executables">Static Executables</a></h2>
<p>We ship <em>zksolc</em> binaries on the <a href="https://github.com/matter-labs/era-compiler-solidity/releases">releases page of <code>matter-labs/era-compiler-solidity</code> repository</a>.
This repository maintains intuitive and stable naming for the executables and provides a changelog for each release. Tools using <em>zksolc</em> will download the binaries from this repository and cache them locally.</p>
<div class="warning">
The <a href="https://github.com/matter-labs/era-compiler-solidity">matter-labs/era-compiler-solidity</a> repository only contains builds for versions 1.4.0 and newer.<br>
You can download older versions from <a href="https://github.com/matter-labs/zksolc-bin/tree/main">the main branch</a> or <a href="https://github.com/matter-labs/zksolc-bin/releases">the releases page</a> of the deprecated repository for zksolc executables.<br>
If any of your projects are still using the old locations, please change their download URLs to <a href="https://github.com/matter-labs/era-compiler-solidity/releases">the new one</a>.
</div>
<blockquote>
<p>All binaries are statically linked and must work on all recent platforms without issues.
<em>zksolc</em> is fully written in Rust, aiming to minimize incompatibilities with the environment.</p>
</blockquote>
<h2 id="building-from-source"><a class="header" href="#building-from-source">Building from Source</a></h2>
<blockquote>
<p>Please consider using the pre-built executables before building from source.
Building from source is only necessary for development, research, and debugging purposes.
Deployment and production use cases should rely only on <a href="01-installation.html#static-executables">the officially released executables</a>.</p>
</blockquote>
<ol>
<li>
<p>Install the necessary system-wide dependencies.</p>
<ul>
<li>For Linux (Debian):</li>
</ul>
<pre><code class="language-shell">apt install cmake ninja-build curl git libssl-dev pkg-config clang lld
</code></pre>
<ul>
<li>For Linux (Arch):</li>
</ul>
<pre><code class="language-shell">pacman -Syu which cmake ninja curl git pkg-config clang lld
</code></pre>
<ul>
<li>
<p>For MacOS:</p>
<ol>
<li>
<p>Install the <em>Homebrew</em> package manager by following the instructions at <a href="https://brew.sh">brew.sh</a>.</p>
</li>
<li>
<p>Install the necessary system-wide dependencies:</p>
<pre><code class="language-shell">brew install cmake ninja coreutils
</code></pre>
</li>
<li>
<p>Install a recent build of the LLVM/<a href="https://clang.llvm.org">Clang</a> compiler using one of the following tools:</p>
<ul>
<li><a href="https://developer.apple.com/xcode/">Xcode</a></li>
<li><a href="https://developer.apple.com/library/archive/technotes/tn2339/_index.html">Apple’s Command Line Tools</a></li>
<li>Your preferred package manager.</li>
</ul>
</li>
</ol>
</li>
</ul>
</li>
<li>
<p>Install Rust.</p>
<p>The easiest way to do it is following the latest <a href="https://www.rust-lang.org/tools/install">official instructions</a>.</p>
</li>
</ol>
<blockquote>
<p>The Rust version used for building is pinned in the <a href="../rust-toolchain.toml">rust-toolchain.toml</a> file at the repository root.
<em>cargo</em> will automatically download the pinned version of <em>rustc</em> when you start building the project.</p>
</blockquote>
<ol start="3">
<li>
<p>Clone and checkout this repository.</p>
<pre><code class="language-shell">git clone https://github.com/matter-labs/era-compiler-solidity
</code></pre>
</li>
<li>
<p>Install the ZKsync LLVM framework builder. This tool clones the <a href="https://github.com/matter-labs/era-compiler-llvm">repository of ZKsync LLVM Framework</a> and runs a sequence of build commands tuned for the needs of ZKsync compiler toolchain.</p>
<pre><code class="language-shell">cargo install compiler-llvm-builder
</code></pre>
<p>To fine-tune your build of ZKsync LLVM framework, refer to the section <a href="01-installation.html#fine-tuning-zksync-llvm-build">Fine tuning ZKsync LLVM build</a></p>
</li>
</ol>
<blockquote>
<p>Always use the latest version of the builder to benefit from the latest features and bug fixes.
To check for new versions and update the builder, simply run <code>cargo install compiler-llvm-builder</code> again, even if you have already installed the builder.
The builder is not the ZKsync LLVM framework itself, but a tool to build it.
By default, it is installed in <code>~/.cargo/bin/</code>, which is usually added to your <code>PATH</code> during the Rust installation process.</p>
</blockquote>
<ol start="5">
<li>
<p>Clone and build the ZKsync LLVM framework using the <code>zksync-llvm</code> tool.</p>
<pre><code class="language-shell"># Navigate to the root of your local copy of this repository.
cd era-compiler-solidity
# Clone the ZKsync LLVM framework. The branch is specified in the file `LLVM.lock`.
zksync-llvm clone
# Build the ZKsync LLVM framework.
zksync-llvm build
</code></pre>
<p>For more information and available build options, run <code>zksync-llvm build --help</code>.</p>
<p>You can also clone and build LLVM framework outside of the repository root.
In this case, do the following:</p>
<ol>
<li>
<p>Provide an <code>LLVM.lock</code> file in the directory where you run <code>zksync-llvm</code>.
See the <a href="../LLVM.lock">default LLVM.lock for an example</a>.</p>
</li>
<li>
<p>Ensure that <code>LLVM.lock</code> selects the correct branch of the <a href="https://github.com/matter-labs/era-compiler-llvm">ZKsync LLVM Framework repository</a>.</p>
</li>
<li>
<p>Before proceeding to the next step, set the environment variable <code>LLVM_SYS_170_PREFIX</code> to the path of the directory with the LLVM build artifacts.
Typically, it ends with <code>target-llvm/build-final</code>, which is the default LLVM target directory of the LLVM builder. For example:</p>
<pre><code class="language-shell">export LLVM_SYS_170_PREFIX=~/repositories/era-compiler-solidity/target-llvm/build-final 
</code></pre>
</li>
</ol>
</li>
<li>
<p>Build the <em>zksolc</em> executable.</p>
<pre><code class="language-shell">cargo build --release
</code></pre>
<p>The <em>zksolc</em> executable will appear at <code>./target/release/zksolc</code>, where you can run it directly or move it to another location.</p>
<p>If <em>cargo</em> cannot find the LLVM build artifacts, return to the previous step and ensure that the <code>LLVM_SYS_170_PREFIX</code> environment variable is set to the absolute path of the directory <code>target-llvm/build-final</code>.</p>
</li>
</ol>
<h2 id="tuning-the-zksync-llvm-build"><a class="header" href="#tuning-the-zksync-llvm-build">Tuning the ZKsync LLVM build</a></h2>
<ul>
<li>
<p>For more information and available build options, run <code>zksync-llvm build --help</code>.</p>
</li>
<li>
<p>Use the <code>--use-ccache</code> option to speed up the build process if you have <a href="https://ccache.dev">ccache</a> installed.</p>
</li>
<li>
<p>To build ZKsync LLVM framework using specific C and C++ compilers, pass additional arguments to <a href="https://cmake.org/">CMake</a> using the <code>--extra-args</code> option:</p>
<pre><code class="language-shell"># Pay special attention to character escaping.

zksync-llvm build \
  --use-ccache \
  --extra-args \
    '\-DCMAKE_C_COMPILER=/opt/homebrew/Cellar/llvm@18/18.1.8/bin/clang' \
    '\-DCMAKE_BUILD_TYPE=Release' \
    '\-DCMAKE_CXX_COMPILER=/opt/homebrew/Cellar/llvm@18/18.1.8/bin/clang++' 
</code></pre>
</li>
</ul>
<h3 id="building-llvm-manually"><a class="header" href="#building-llvm-manually">Building LLVM manually</a></h3>
<ul>
<li>
<p>If you prefer building <a href="https://github.com/matter-labs/era-compiler-llvm">your ZKsync LLVM</a> manually, include the following flags in your CMake command:</p>
<pre><code class="language-shell"># We recommended using the latest version of CMake.

-DLLVM_TARGETS_TO_BUILD='EraVM;EVM'
-DLLVM_ENABLE_PROJECTS='lld'
-DBUILD_SHARED_LIBS='Off'
</code></pre>
</li>
</ul>
<blockquote>
<p>For most users, the <a href="01-installation.html#building-from-source">ZKsync LLVM builder</a> is the recommended way to build the ZKsync LLVM framework.
This section exists for the ZKsync toolchain developers and researchers with specific requirements and experience with the LLVM framework.
We are going to present a more detailed guide for LLVM contributors in the future.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="command-line-interface-cli"><a class="header" href="#command-line-interface-cli">Command Line Interface (CLI)</a></h1>
<p>The CLI of <em>zksolc</em> is designed with resemblance to the CLI of <em>solc</em>. There are several main input/output (I/O) modes in the <em>zksolc</em> interface:</p>
<ul>
<li><a href="02-command-line-interface.html#basic-cli">Basic CLI</a></li>
<li><a href="./03-standard-json.html">Standard JSON</a></li>
<li><a href="./04-combined-json.html">Combined JSON</a></li>
</ul>
<p>The basic CLI and combined JSON modes are more light-weight and suitable for calling from the shell. The standard JSON mode is similar to client-server interaction, thus more suitable for using from other applications, such as <a href="https://github.com/matter-labs/foundry-zksync">Foundry</a>.</p>
<blockquote>
<p>All toolkits using <em>zksolc</em> must be operating in standard JSON mode and follow <a href="./03-standard-json.html">its specification</a>.
It will make the toolkits more robust and future-proof, as the standard JSON mode is the most versatile and used for the majority of popular projects.</p>
</blockquote>
<p>This page focuses on the basic CLI mode. For more information on the other modes, see the corresponding <a href="./04-combined-json.html">combined JSON</a> and <a href="./03-standard-json.html">standard JSON</a> pages.</p>
<h2 id="basic-cli"><a class="header" href="#basic-cli">Basic CLI</a></h2>
<p>Basic CLI mode is the simplest way to compile a file with the source code.</p>
<p>To compile a basic Solidity contract, make sure that <a href="02-command-line-interface.html#--solc">the <em>solc</em> compiler</a> is present in your environment and run the example from <a href="02-command-line-interface.html#--bin">the <em>--bin</em> section</a>.</p>
<p>The rest of this section describes the available CLI options and their usage. You may also check out <code>zksolc --help</code> for a quick reference.</p>
<h3 id="--solc"><a class="header" href="#--solc"><code>--solc</code></a></h3>
<p>Specifies the path to the <em>solc</em> compiler. Useful when the <em>solc</em> compiler is not available in the system path.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --solc '/path/to/solc'
</code></pre>
<blockquote>
<p>Examples in the subsequent sections assume that <em>solc</em> <a href="./01-installation.html#installing-solc">is installed and available</a> in the system path.
If you prefer specifying the full path to <em>solc</em>, use the <code>--solc</code> option with the examples below.</p>
</blockquote>
<h3 id="--bin"><a class="header" href="#--bin"><code>--bin</code></a></h3>
<p>Enables the output of compiled bytecode. The following command compiles a Solidity file and prints the bytecode:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.sol:Simple =======
Binary:
0000008003000039000000400030043f0000000100200190000000130000c13d...
</code></pre>
<p>It is possible to dry-run the compilation without writing any output. To do this, simply omit <code>--bin</code> and other output options:</p>
<pre><code class="language-bash">zksolc './Simple.sol'
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Compiler run successful. No output requested. Use flags --metadata, --asm, --bin.
</code></pre>
<h3 id="input-files"><a class="header" href="#input-files">Input Files</a></h3>
<p><em>zksolc</em> supports multiple input files. The following command compiles two Solidity files and prints the bytecode:</p>
<pre><code class="language-bash">zksolc './Simple.sol' './Complex.sol' --bin
</code></pre>
<p><a href="https://docs.soliditylang.org/en/latest/path-resolution.html#import-remapping">Solidity import remappings</a> are passed in the way as input files, but they are distinguished by a <code>=</code> symbol between source and destination. The following command compiles a Solidity file with a remapping and prints the bytecode:</p>
<pre><code class="language-bash">zksolc './Simple.sol' 'github.com/ethereum/dapp-bin/=/usr/local/lib/dapp-bin/' --bin
</code></pre>
<p><em>zksolc</em> does not handle remappings itself, but only passes them through to <em>solc</em>.
Visit <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#base-path-and-import-remapping">the <em>solc</em> documentation</a> to learn more about the processing of remappings.</p>
<h3 id="--libraries"><a class="header" href="#--libraries"><code>--libraries</code></a></h3>
<p>Specifies the libraries to link with compiled contracts. The option accepts multiple string arguments. The safest way is to wrap each argument in single quotes, and separate them with a space.</p>
<p>The specifier has the following format: <code>&lt;ContractPath&gt;:&lt;ContractName&gt;=&lt;LibraryAddress&gt;</code>.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --libraries 'Simple.sol:Test=0x1234567890abcdef1234567890abcdef12345678'
</code></pre>
<p>There are two ways of linking libraries:</p>
<ol>
<li>At compile time, immediately after the contract is compiled.</li>
<li>At deploy time (a.k.a. post-compile time), right before the contract is deployed.</li>
</ol>
<p>The use case above describes linking at compile time. For linking at deploy time, see the <a href="./05-linker.html">linker documentation</a>.</p>
<h3 id="--base-path---include-path---allow-paths"><a class="header" href="#--base-path---include-path---allow-paths"><code>--base-path</code>, <code>--include-path</code>, <code>--allow-paths</code></a></h3>
<p>These options are used to specify Solidity import resolution settings. They are not used by <em>zksolc</em> and only passed through to <em>solc</em> like import remappings.</p>
<p>Visit <a href="https://docs.soliditylang.org/en/latest/path-resolution.html">the <em>solc</em> documentation</a> to learn more about the processing of these options.</p>
<h3 id="--asm"><a class="header" href="#--asm"><code>--asm</code></a></h3>
<p>Enables the output of contract assembly. The assembly format depends on the <a href="02-command-line-interface.html#--target"><em>--target</em></a> architecture the contract is compiled for.</p>
<p>For the EraVM assembly specification, visit the <a href="https://docs.zksync.io/zk-stack/components/compiler/specification/binary-layout">EraVM documentation</a>.</p>
<p>EVM assembly is not supported yet.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc Simple.sol --asm
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.sol:Simple =======
EraVM assembly:
        .text
        .file   "Simple.sol:Simple"
        .globl  __entry
__entry:
.func_begin0:
        add     128, r0, r3
        stm.h   64, r3
...
</code></pre>
<p>The <code>--asm</code> option can be combined with other output options, such as <code>--bin</code>:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --asm --bin
</code></pre>
<h3 id="--metadata"><a class="header" href="#--metadata"><code>--metadata</code></a></h3>
<p>Enables the output of contract metadata. The metadata is a JSON object that contains information about the contract, such as its name, source code hash, the list of dependencies, compiler versions, and so on.</p>
<p>The <em>zksolc</em> metadata format is compatible with the <a href="https://docs.soliditylang.org/en/latest/metadata.html#contract-metadata">Solidity metadata format</a>. This means that the metadata output can be used with other tools that support Solidity metadata. Essentially, <em>solc</em> metadata is a part of <em>zksolc</em> metadata, and it is included as <code>source_metadata</code> without any modifications.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --metadata
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.sol:Simple =======
Metadata:
{"llvm_options":[],"optimizer_settings":{"is_debug_logging_enabled":false,"is_fallback_to_size_enabled":false,"is_verify_each_enabled":false,"level_back_end":"Aggressive","level_middle_end":"Aggressive","level_middle_end_size":"Zero"},"solc_version":"x.y.z","solc_zkvm_edition":null,"source_metadata":{...},"zk_version":"x.y.z"}
</code></pre>
<h3 id="--output-dir"><a class="header" href="#--output-dir"><code>--output-dir</code></a></h3>
<p>Specifies the output directory for build artifacts. Can only be used in <a href="02-command-line-interface.html#basic-cli">basic CLI</a> and <a href="./04-combined-json.html">combined JSON</a> modes.</p>
<p>Usage in basic CLI mode:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --asm --metadata --output-dir './build/'
ls './build/Simple.sol'
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Compiler run successful. Artifact(s) can be found in directory "build".
...
Test.zasm       Test.zbin       Test_meta.json
</code></pre>
<p>Usage in combined JSON mode:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --combined-json 'bin,asm,metadata' --output-dir './build/'
ls './build/'
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Compiler run successful. Artifact(s) can be found in directory "build".
...
combined.json
</code></pre>
<h3 id="--overwrite"><a class="header" href="#--overwrite"><code>--overwrite</code></a></h3>
<p>Overwrites the output files if they already exist in the output directory. By default, <em>zksolc</em> does not overwrite existing files.</p>
<p>Can only be used in combination with the <a href="02-command-line-interface.html#--output-dir"><code>--output-dir</code></a> option.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --combined-json 'bin,asm,metadata' --output-dir './build/' --overwrite
</code></pre>
<p>If the <code>--overwrite</code> option is not specified and the output files already exist, <em>zksolc</em> will print an error message and exit:</p>
<pre><code class="language-text">Error: Refusing to overwrite an existing file "build/combined.json" (use --overwrite to force).
</code></pre>
<h3 id="--version"><a class="header" href="#--version"><code>--version</code></a></h3>
<p>Prints the version of <em>zksolc</em> and the hash of the LLVM commit it was built with.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc --version
</code></pre>
<h3 id="--help"><a class="header" href="#--help"><code>--help</code></a></h3>
<p>Prints the help message.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc --help
</code></pre>
<h2 id="other-io-modes"><a class="header" href="#other-io-modes">Other I/O Modes</a></h2>
<blockquote>
<p>The mode-altering CLI options are mutually exclusive. This means that only one of the options below can be enabled at a time:</p>
<ul>
<li><code>--standard-json</code></li>
<li><code>--combined-json</code></li>
<li><code>--yul</code></li>
<li><code>--llvm-ir</code></li>
<li><code>--eravm-assembly</code></li>
<li><code>--disassemble</code></li>
<li><code>--link</code></li>
</ul>
</blockquote>
<h3 id="--standard-json"><a class="header" href="#--standard-json"><code>--standard-json</code></a></h3>
<p>For the standard JSON mode usage, see the <a href="./03-standard-json.html">Standard JSON</a> page.</p>
<h3 id="--combined-json"><a class="header" href="#--combined-json"><code>--combined-json</code></a></h3>
<p>For the combined JSON mode usage, see the <a href="./04-combined-json.html">Combined JSON</a> page.</p>
<h2 id="zksolc-compilation-settings"><a class="header" href="#zksolc-compilation-settings"><em>zksolc</em> Compilation Settings</a></h2>
<p>The options in this section are only configuring the <em>zksolc</em> compiler and do not affect the underlying <em>solc</em> compiler.</p>
<h3 id="--optimization---o"><a class="header" href="#--optimization---o"><code>--optimization / -O</code></a></h3>
<p>Sets the optimization level of the LLVM optimizer. Available values are:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Level</th><th style="text-align: left">Meaning</th><th style="text-align: left">Hints</th></tr></thead><tbody>
<tr><td style="text-align: left">0</td><td style="text-align: left">No optimization</td><td style="text-align: left">Best compilation speed: for active development</td></tr>
<tr><td style="text-align: left">1</td><td style="text-align: left">Performance: basic</td><td style="text-align: left">For optimization research</td></tr>
<tr><td style="text-align: left">2</td><td style="text-align: left">Performance: default</td><td style="text-align: left">For optimization research</td></tr>
<tr><td style="text-align: left">3</td><td style="text-align: left">Performance: aggressive</td><td style="text-align: left">Default value. Best performance: for production</td></tr>
<tr><td style="text-align: left">s</td><td style="text-align: left">Size: default</td><td style="text-align: left">For optimization research</td></tr>
<tr><td style="text-align: left">z</td><td style="text-align: left">Size: aggressive</td><td style="text-align: left">Best size: for contracts with size constraints</td></tr>
</tbody></table>
</div>
<p>For most cases, it is fine to use the default value of <code>3</code>. You should only use the level <code>z</code> if you are ready to deliberately sacrifice performance and optimize for size.</p>
<blockquote>
<p>Large contracts may hit the EraVM or EVM bytecode size limit. In this case, it is recommended to use the <a href="02-command-line-interface.html#--fallback-oz"><code>--fallback-Oz</code></a> option rather than set the <code>z</code> level.</p>
</blockquote>
<h3 id="--fallback-oz"><a class="header" href="#--fallback-oz"><code>--fallback-Oz</code></a></h3>
<p>Sets the optimization level to <code>z</code> for contracts that failed to compile due to overrunning the bytecode size constraints.</p>
<p>Under the hood, this option automatically triggers recompilation of contracts with level <code>z</code>. Contracts that were successfully compiled with <a href="02-command-line-interface.html#--optimization---o">the original <code>--optimization</code> setting</a> are not recompiled.</p>
<blockquote>
<p>It is recommended to have this option always enabled to prevent compilation failures due to bytecode size constraints. There are no known downsides to using this option.</p>
</blockquote>
<h3 id="--metadata-hash"><a class="header" href="#--metadata-hash"><code>--metadata-hash</code></a></h3>
<p>Specifies the hash function used for contract metadata.</p>
<p>The following values are allowed:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Value</th><th style="text-align: left">Size</th><th style="text-align: left">Padding</th><th style="text-align: left">Reference</th></tr></thead><tbody>
<tr><td style="text-align: left">none</td><td style="text-align: left">0 B</td><td style="text-align: left">0-32 B</td><td style="text-align: left"></td></tr>
<tr><td style="text-align: left">keccak256</td><td style="text-align: left">32 B</td><td style="text-align: left">0-32 B</td><td style="text-align: left"><a href="https://en.wikipedia.org/wiki/SHA-3">SHA-3 Wikipedia Page</a></td></tr>
<tr><td style="text-align: left">ipfs</td><td style="text-align: left">44 B</td><td style="text-align: left">20-52 B</td><td style="text-align: left"><a href="https://docs.ipfs.tech/">IPFS Documentation</a></td></tr>
</tbody></table>
</div>
<p>The default value is <code>keccak256</code>.</p>
<blockquote>
<p>EraVM requires its bytecode size to be an odd number of 32-byte words. If the size after appending the hash does not satisfy this requirement, the hash is <em>prepended</em> with zeros according to the <em>Padding</em> column in the table above.</p>
</blockquote>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --metadata-hash 'ipfs'
</code></pre>
<h3 id="--enable-eravm-extensions"><a class="header" href="#--enable-eravm-extensions"><code>--enable-eravm-extensions</code></a></h3>
<p>Enables the EraVM extensions.</p>
<p>If this flag is set, calls to addresses <code>0xFFFF</code> and below are substituted by special EraVM instructions.</p>
<p>In Yul mode, the <code>verbatim_*</code> instruction family becomes available.</p>
<p>The full list of EraVM extensions and their usage can be found <a href="./06-eravm-extensions.html">here</a>.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --enable-eravm-extensions
</code></pre>
<h3 id="--suppress-errors"><a class="header" href="#--suppress-errors"><code>--suppress-errors</code></a></h3>
<p>Tells the compiler to suppress specified errors. The option accepts multiple string arguments, so make sure they are properly separated by whitespace.</p>
<p>Only one error can be suppressed with this option: <a href="https://docs.zksync.io/build/developer-reference/best-practices#use-call-over-send-or-transfer"><code>sendtransfer</code></a>.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --suppress-errors 'sendtransfer'
</code></pre>
<h3 id="--suppress-warnings"><a class="header" href="#--suppress-warnings"><code>--suppress-warnings</code></a></h3>
<p>Tells the compiler to suppress specified warnings. The option accepts multiple string arguments, so make sure they are properly separated by whitespace.</p>
<p>Only one warning can be suppressed with this option: <a href="https://docs.zksync.io/build/tooling/foundry/migration-guide/testing#origin-address"><code>txorigin</code></a>.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --suppress-warnings 'txorigin'
</code></pre>
<h3 id="--llvm-options"><a class="header" href="#--llvm-options"><code>--llvm-options</code></a></h3>
<p>Specifies additional options for the LLVM framework. The argument must be a single quoted string following a <code>=</code> separator.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --llvm-options='-eravm-jump-table-density-threshold=10'
</code></pre>
<blockquote>
<p>The <code>--llvm-options</code> option is experimental and must only be used by experienced users. All supported options will be documented in the future.</p>
</blockquote>
<h2 id="solc-compilation-settings"><a class="header" href="#solc-compilation-settings"><em>solc</em> Compilation Settings</a></h2>
<p>The options in this section are only configuring <em>solc</em>, so they are passed directly to its child process, and do not affect the <em>zksolc</em> compiler.</p>
<h3 id="--codegen"><a class="header" href="#--codegen"><code>--codegen</code></a></h3>
<p>Specifies the <em>solc</em> codegen. The following values are allowed:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Value</th><th style="text-align: left">Description</th><th style="text-align: left">Hints</th></tr></thead><tbody>
<tr><td style="text-align: left">evmla</td><td style="text-align: left">EVM legacy assembly</td><td style="text-align: left"><em>solc</em> default for EVM/L1</td></tr>
<tr><td style="text-align: left">yul</td><td style="text-align: left">Yul a.k.a. IR</td><td style="text-align: left"><em>zksolc</em> default for ZKsync</td></tr>
</tbody></table>
</div>
<blockquote>
<p><em>solc</em> uses the <code>evmla</code> codegen by default. However, <em>zksolc</em> uses the <code>yul</code> codegen by default for historical reasons.
Codegens are not equivalent and may lead to different behavior in production.
Make sure that this option is set to <code>evmla</code> if you want your contracts to behave as they would on L1.
For codegen differences, visit the <a href="https://docs.soliditylang.org/en/latest/ir-breaking-changes.html">solc IR breaking changes page</a>.
<em>zksolc</em> is going to switch to the <code>evmla</code> codegen by default in the future in order to have more parity with L1.</p>
</blockquote>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --codegen 'evmla'
</code></pre>
<h3 id="--evm-version"><a class="header" href="#--evm-version"><code>--evm-version</code></a></h3>
<p>Specifies the EVM version <em>solc</em> will produce artifacts for. Only artifacts such as Yul and EVM assembly are known to be affected by this option. For instance, if the EVM version is set to <em>cancun</em>, then Yul and EVM assembly may contain <code>MCOPY</code> instructions.</p>
<blockquote>
<p>EVM version only affects IR artifacts produced by <em>solc</em> and does not affect EraVM bytecode produced by <em>zksolc</em>.</p>
</blockquote>
<p>The default value is chosen by <em>solc</em>. For instance, <em>solc</em> v0.8.24 and older use <em>shanghai</em> by default, whereas newer ones use <em>cancun</em>.</p>
<p>The following values are allowed, however have in mind that newer EVM versions are only supported by newer versions of <em>solc</em>:</p>
<ul>
<li>homestead</li>
<li>tangerineWhistle</li>
<li>spuriousDragon</li>
<li>byzantium</li>
<li>constantinople</li>
<li>petersburg</li>
<li>istanbul</li>
<li>berlin</li>
<li>london</li>
<li>paris</li>
<li>shanghai</li>
<li>cancun</li>
<li>prague</li>
</ul>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --evm-version 'cancun'
</code></pre>
<p>For more information on how <em>solc</em> handles EVM versions, see its <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#setting-the-evm-version-to-target">EVM version documentation</a>.</p>
<h3 id="--metadata-literal"><a class="header" href="#--metadata-literal"><code>--metadata-literal</code></a></h3>
<p>Tells <em>solc</em> to store referenced sources as literal data in the metadata output.</p>
<blockquote>
<p>This option only affects the contract metadata output produced by <em>solc</em>, and does not affect artifacts produced by <em>zksolc</em>.</p>
</blockquote>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --metadata-literal
</code></pre>
<h2 id="multi-language-support"><a class="header" href="#multi-language-support">Multi-Language Support</a></h2>
<p><em>zksolc</em> supports input in multiple programming languages:</p>
<ul>
<li><a href="https://soliditylang.org/">Solidity</a></li>
<li><a href="https://docs.soliditylang.org/en/latest/yul.html">Yul</a></li>
<li><a href="https://llvm.org/docs/LangRef.html">LLVM IR</a></li>
<li><a href="https://docs.zksync.io/zk-stack/components/compiler/specification/binary-layout">EraVM assembly</a></li>
</ul>
<p>The following sections outline how to use <em>zksolc</em> with these languages.</p>
<h3 id="--yul"><a class="header" href="#--yul"><code>--yul</code></a></h3>
<p>Enables the Yul mode. In this mode, input is expected to be in the Yul language. The output works the same way as with Solidity input.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc --yul './Simple.yul' --bin
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.yul =======
Binary:
0000000100200190000000060000c13d0000002a01000039000000000010043f...
</code></pre>
<p><em>zksolc</em> is able to compile Yul without <em>solc</em>. However, using <em>solc</em> is still recommended as it provides additional validation, diagnostics and better error messages:</p>
<pre><code class="language-bash">zksolc --yul './Simple.yul' --bin --solc '/path/to/solc'
</code></pre>
<p><em>zksolc</em> features its own dialect of Yul with extensions for EraVM. If <a href="./06-eravm-extensions.html">the extensions</a> are enabled, it is not possible to use <em>solc</em> for validation.</p>
<h3 id="--llvm-ir"><a class="header" href="#--llvm-ir"><code>--llvm-ir</code></a></h3>
<p>Enables the LLVM IR mode. In this mode, input is expected to be in the LLVM IR language. The output works the same way as with Solidity input.</p>
<p>Unlike <em>solc</em>, <em>zksolc</em> is an LLVM-based compiler toolchain, so it uses LLVM IR as an intermediate representation. It is not recommended to write LLVM IR manually, but it can be useful for debugging and optimization purposes. LLVM IR is more low-level than Yul in the ZKsync compiler toolchain IR hierarchy, so <em>solc</em> is not used for compilation.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc --llvm-ir './Simple.ll' --bin
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.ll =======
Binary:
000000000002004b000000070000613d0000002001000039000000000010043f...
</code></pre>
<h3 id="--eravm-assembly"><a class="header" href="#--eravm-assembly"><code>--eravm-assembly</code></a></h3>
<p>Enables the EraVM Assembly mode. In this mode, input is expected to be in the EraVM assembly language. The output works the same way as with Solidity input.</p>
<p>EraVM assembly is a representation the closest to EraVM bytecode. It is not recommended to write EraVM assembly manually, but it can be even more useful for debugging and optimization purposes than LLVM IR.</p>
<p>For the EraVM assembly specification, visit the <a href="https://docs.zksync.io/zk-stack/components/compiler/specification/binary-layout">EraVM documentation</a>.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc --eravm-assembly './Simple.zasm' --bin
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.zasm =======
Binary:
000000000120008c000000070000613d00000020010000390000000000100435...
</code></pre>
<h2 id="multi-target-support"><a class="header" href="#multi-target-support">Multi-Target Support</a></h2>
<p><em>zksolc</em> is an LLVM-based compiler toolchain, so it is easily extensible to support multiple target architectures. The following targets are supported:</p>
<ul>
<li><code>eravm</code> — <a href="https://docs.zksync.io/zk-stack/components/zksync-evm">EraVM</a> (default).</li>
<li><code>evm</code> — <a href="https://ethereum.org/en/developers/docs/evm/">EVM</a> (under development and only available for testing).</li>
</ul>
<h3 id="--target"><a class="header" href="#--target"><code>--target</code></a></h3>
<p>Specifies the target architecture for the compiled contract.</p>
<div class="warning">
The <code>--target</code> option is experimental and must be passed as a CLI argument in all modes including combined JSON and standard JSON.
</div>
<p>Usage:</p>
<pre><code class="language-bash">zksolc Simple.sol --bin --target evm
</code></pre>
<p>Output:</p>
<pre><code class="language-text">======= Simple.sol:Simple =======
Binary:
0000008003000039000000400030043f0000000100200190000000130000c13d...
</code></pre>
<h2 id="integrated-tooling"><a class="header" href="#integrated-tooling">Integrated Tooling</a></h2>
<p><em>zksolc</em> includes several tools provided by the LLVM framework out of the box, such as disassembler and linker. The following sections describe the usage of these tools.</p>
<h3 id="--disassemble"><a class="header" href="#--disassemble"><code>--disassemble</code></a></h3>
<p>Enables the disassembler mode.</p>
<p><em>zksolc</em> includes an LLVM-based disassembler that can be used to disassemble compiled bytecode.</p>
<p>The disassembler input must be files with a hexadecimal string. The disassembler output is a human-readable representation of the bytecode, also known as EraVM assembly.</p>
<p>Usage:</p>
<pre><code class="language-bash">cat './input.zbin'
</code></pre>
<p>Output:</p>
<pre><code class="language-text">0x0000008003000039000000400030043f0000000100200190000000140000c13d00000000020...
</code></pre>
<pre><code class="language-bash">zksolc --disassemble './input.zbin'
</code></pre>
<p>Output:</p>
<pre><code class="language-text">File `input.zbin` disassembly:

       0: 00 00 00 80 03 00 00 39       add     128, r0, r3
       8: 00 00 00 40 00 30 04 3f       stm.h   64, r3
      10: 00 00 00 01 00 20 01 90       and!    1, r2, r0
      18: 00 00 00 14 00 00 c1 3d       jump.ne 20
      20: 00 00 00 00 02 01 00 19       add     r1, r0, r2
      28: 00 00 00 0b 00 20 01 98       and!    code[11], r2, r0
      30: 00 00 00 23 00 00 61 3d       jump.eq 35
      38: 00 00 00 00 01 01 04 3b       ldp     r1, r1
</code></pre>
<h3 id="--link"><a class="header" href="#--link"><code>--link</code></a></h3>
<p>Enables the linker mode.</p>
<p>For the linker usage, visit <a href="./05-linker.html">the linker documentation</a>.</p>
<h2 id="debugging"><a class="header" href="#debugging">Debugging</a></h2>
<h3 id="--debug-output-dir"><a class="header" href="#--debug-output-dir"><code>--debug-output-dir</code></a></h3>
<p>Specifies the directory to store intermediate build artifacts. The artifacts can be useful for debugging and research.</p>
<p>The directory is created if it does not exist. If artifacts are already present in the directory, they are overwritten.</p>
<p>The intermediate build artifacts can be:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Codegen</th><th style="text-align: left">File extension</th></tr></thead><tbody>
<tr><td style="text-align: left">EVM Assembly</td><td style="text-align: left">evmla</td><td style="text-align: left"><em>evmla</em></td></tr>
<tr><td style="text-align: left">EthIR</td><td style="text-align: left">evmla</td><td style="text-align: left"><em>ethir</em></td></tr>
<tr><td style="text-align: left">Yul</td><td style="text-align: left">yul</td><td style="text-align: left"><em>yul</em></td></tr>
<tr><td style="text-align: left">LLVM IR</td><td style="text-align: left">evmla, yul</td><td style="text-align: left"><em>ll</em></td></tr>
<tr><td style="text-align: left">EraVM Assembly</td><td style="text-align: left">evmla, yul</td><td style="text-align: left"><em>zasm</em></td></tr>
</tbody></table>
</div>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --debug-output-dir './debug/'
ls './debug/'
</code></pre>
<p>Output:</p>
<pre><code class="language-text">Compiler run successful. No output requested. Use flags --metadata, --asm, --bin.
...
Simple.sol.C.runtime.optimized.ll
Simple.sol.C.runtime.unoptimized.ll
Simple.sol.C.yul
Simple.sol.C.zasm
Simple.sol.Test.runtime.optimized.ll
Simple.sol.Test.runtime.unoptimized.ll
Simple.sol.Test.yul
Simple.sol.Test.zasm
</code></pre>
<p>The output file name is constructed as follows: <code>&lt;ContractPath&gt;.&lt;ContractName&gt;.&lt;Modifiers&gt;.&lt;Extension&gt;</code>.</p>
<h3 id="--llvm-verify-each"><a class="header" href="#--llvm-verify-each"><code>--llvm-verify-each</code></a></h3>
<p>Enables the verification of the LLVM IR after each optimization pass. This option is useful for debugging and research purposes.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --llvm-verify-each
</code></pre>
<h3 id="--llvm-debug-logging"><a class="header" href="#--llvm-debug-logging"><code>--llvm-debug-logging</code></a></h3>
<p>Enables the debug logging of the LLVM IR optimization passes. This option is useful for debugging and research purposes.</p>
<p>Usage:</p>
<pre><code class="language-bash">zksolc './Simple.sol' --bin --llvm-debug-logging
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="standard-json"><a class="header" href="#standard-json">Standard JSON</a></h1>
<p>Standard JSON is a protocol for interaction with the <em>zksolc</em> and <em>solc</em> compilers. This protocol must be implemented by toolkits such as Hardhat and Foundry.</p>
<p>The protocol uses two data formats for communication: <a href="03-standard-json.html#input-json">input JSON</a> and <a href="03-standard-json.html#output-json">output JSON</a>.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>Input JSON can be provided by-value via the <code>--standard-json</code> option:</p>
<pre><code class="language-shell">zksolc --standard-json './input.json'
</code></pre>
<p>Alternatively, the input JSON can be fed to <em>zksolc</em> via <em>stdin</em>:</p>
<pre><code class="language-shell">cat './input.json' | zksolc --standard-json
</code></pre>
<p>After receiving output JSON, the calling program can process it according to its needs. For projects with deployable libraries, <a href="./02-command-line-interface.html#--link">calling the linker</a> is usually required before compiled contracts are ready for deployment.</p>
<blockquote>
<p>For the sake of interface unification, <em>zksolc</em> will always return with exit code 0 and have its standard JSON output printed to <em>stdout</em>.
It differs from <em>solc</em> that may return with exit code 1 and a free-formed error in some cases, such as when the standard JSON input file is missing, even though <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#compiler-input-and-output-json-description">the <em>solc</em> documentation claims otherwise</a>.</p>
</blockquote>
<p>The formats below are modifications of the original standard JSON <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#input-description">input</a> and <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#output-description">output</a> formats implemented by <em>solc</em>. It means that there are:</p>
<ul>
<li><em>zksolc</em>-specific options that are not present in the original format: they are marked as <code>zksolc</code> in the specifications below.</li>
<li><em>solc</em>-specific options that are not supported by <em>zksolc</em>: they are not mentioned in the specifications below.</li>
</ul>
<h2 id="input-json"><a class="header" href="#input-json">Input JSON</a></h2>
<p>The input JSON provides the compiler with the source code and settings for the compilation. The example below serves as the specification of the input JSON format.</p>
<p>Internally, <em>zksolc</em> extracts all <em>zksolc</em>-specific options and converts the input JSON to the subset expected by <em>solc</em> before calling it.</p>
<pre><code class="language-javascript">{
  // Required: Source code language.
  // Currently supported: "Solidity", "Yul", "LLVM IR", "EraVM Assembly".
  "language": "Solidity",
  // Required: Source code files to compile.
  // The keys here are the "global" names of the source files. Imports can be using other file paths via remappings.
  "sources": {
    // In source file entry, either but not both "urls" and "content" must be specified.
    "myFile.sol": {
      // Required (unless "content" is used): URL(s) to the source file.
      "urls": [
        // In Solidity mode, directories must be added to the command-line via "--allow-paths &lt;path&gt;" for imports to work.
        // It is possible to specify multiple URLs for a single source file. In this case the first successfully resolved URL will be used.
        "/tmp/path/to/file.sol"
      ],
      // Required (unless "urls" is used): Literal contents of the source file.
      "content": "contract settable is owned { uint256 private x = 0; function set(uint256 _x) public { if (msg.sender == owner) x = _x; } }"
    }
  },

  // Required: Compilation settings.
  "settings": {
    // Optional: Optimizer settings.
    "optimizer": {
      // Optional, zksolc: Set the zksolc LLVM optimizer level.
      // Available options:
      // -0: do not optimize
      // -1: basic optimizations for gas usage
      // -2: advanced optimizations for gas usage
      // -3: all optimizations for gas usage
      // -s: basic optimizations for deployment cost
      // -z: all optimizations for deployment cost
      // Default: 3.
      "mode": "3",
      // Optional, zksolc: Re-run the compilation with "mode": "z" if the compilation with "mode": "3" fails due to EraVM bytecode size limit.
      // Used on a per-contract basis and applied automatically, so some contracts will end up compiled with "mode": "3", and others with "mode": "z".
      // Default: false.
      "fallbackToOptimizingForSize": false
    },

    // Optional: Sorted list of remappings.
    // Important: Only used with Solidity input.
    "remappings": [ ":g=/dir" ],
    // Optional: Addresses of the libraries.
    // If not all library addresses are provided here, it will result in unlinked bytecode files that will require post-compile-time linking before deployment.
    // Important: Only used with Solidity, Yul, and LLVM IR input.
    "libraries": {
      // The top level key is the name of the source file where the library is used.
      // If remappings are used, this source file should match the global path after remappings were applied.
      "myFile.sol": {
        // Source code library name and address where it is deployed.
        "MyLib": "0x123123..."
      }
    },

    // Optional: Version of the EVM solc will produce IR for.
    // Affects type checking and code generation.
    // Can be "homestead", "tangerineWhistle", "spuriousDragon", "byzantium", "constantinople", "petersburg", "istanbul", "berlin", "london", "paris", "shanghai", "cancun" or "prague" (experimental).
    // Only used with Solidity, and only affects Yul and EVM assembly codegen. For instance, with version "cancun", solc will produce `MCOPY` instructions, whereas with older EVM versions it will not.
    // Default: chosen by solc, is version-dependent.
    "evmVersion": "cancun",
    // Optional: Select the desired output.
    // Important: zksolc does not support per-file and per-contract selection.
    //
    // Available file-level options, must be listed under "*"."":
    //   ast                       AST of all source files
    //
    // Available contract-level options, must be listed under "*"."*":
    //   abi                       Solidity ABI
    //   evm.methodIdentifiers     Solidity function hashes
    //   storageLayout             Slots, offsets and types of the contract's state variables in storage
    //   transientStorageLayout    Slots, offsets and types of the contract's state variables in transient storage
    //   devdoc                    Developer documentation (natspec)
    //   userdoc                   User documentation (natspec)
    //   metadata                  Metadata
    //   evm.legacyAssembly        EVM assembly produced by solc
    //   irOptimized               Yul produced by solc
    //   eravm.assembly            EraVM assembly produced by zksolc
    //
    // Default: no flags are selected, so only bytecode is emitted.
    "outputSelection": {
      "*": {
        "": [
          "ast" // Enable the AST output for the project.
        ],
        "*": [
          "metadata", // Enable the metadata output for the project.
          "irOptimized", // Enable the Yul output for the project.
          "eravm.assembly" // Enable the EraVM assembly output for the project.
        ]
      }
    },
    // Optional: Metadata settings.
    "metadata": {
      // Optional: Use the given hash method for the metadata hash that is appended to the bytecode.
      // Available options: "none", "keccak256", "ipfs".
      // The metadata hash can be removed from the bytecode via option "none".
      // Default: "keccak256".
      "hashType": "ipfs",
      // Optional: Use only literal content and not URLs.
      // Passed through to solc and does not affect the zksolc-specific metadata.
      // Default: false.
      "useLiteralContent": true
    },

    // Optional: Solidity codegen.
    // Can be "evmla" or "yul".
    // In contract to solc, zksolc uses "Yul" codegen by default for solc v0.8.0 and newer. It will be fixed soon, so solc and zksolc defaults will be the same.
    // Default: "evmla" for solc &lt;0.8.0, "yul" for solc &gt;=0.8.0.
    "codegen": "Yul",
    // Optional, Deprecated, zksolc: Use "codegen" instead.
    // Default: false.
    "forceEVMLA": true,
    // Optional, zksolc: Enables the EraVM extensions in Solidity and Yul modes.
    // The extensions include EraVM-specific opcodes and features, such as call forwarding and usage of additional memory spaces.
    // Default: false.
    "enableEraVMExtensions": true,

    // Optional, zksolc: extra LLVM settings.
    "LLVMOptions": [
      "-eravm-jump-table-density-threshold", "10",
      "-tail-dup-size", "6",
      "-eravm-enable-split-loop-phi-live-ranges",
      "-tail-merge-only-bbs-without-succ",
      "-join-globalcopies",
      "-disable-early-taildup"
    ],
    // Optional, zksolc: suppressed errors.
    // Available options: "sendtransfer", "assemblycreate".
    "suppressedErrors": [
      "sendtransfer",
      "assemblycreate"
    ],
    // Optional, zksolc: suppressed warnings.
    // Available options: "txorigin".
    "suppressedWarnings": [
      "txorigin"
    ]
  }
}
</code></pre>
<h2 id="output-json"><a class="header" href="#output-json">Output JSON</a></h2>
<p>The output JSON contains all artifacts produced by both <em>zksolc</em> and <em>solc</em> compilers. The example below serves as the specification of the input JSON format.</p>
<p>If <em>solc</em> is provided to <em>zksolc</em>, the output JSON is initially generated by <em>solc</em>, and ZKsync-specific data is appended by <em>zksolc</em> afterwards. If <em>solc</em> is not provided, the output JSON is generated by <em>zksolc</em> alone.</p>
<pre><code class="language-javascript">{
  // Required: File-level outputs.
  "sources": {
    "sourceFile.sol": {
      // Required: Identifier of the source.
      "id": 1,
      // Optional: The AST object.
      // Corresponds to "ast" in the outputSelection settings.
      "ast": {/* ... */}
    }
  },

  // Required: Contract-level outputs.
  "contracts": {
    // The source name.
    "sourceFile.sol": {
      // The contract name.
      // If the language only supports one contract per file, this field equals to the source name.
      "ContractName": {
        // Optional: The Ethereum Contract ABI (object).
        // See https://docs.soliditylang.org/en/develop/abi-spec.html.
        // Corresponds to "abi" in the outputSelection settings.
        // Provided by solc and passed through by zksolc.
        "abi": [/* ... */],
        // Optional: Storage layout (object).
        // Corresponds to "storageLayout" in the outputSelection settings.
        // Provided by solc and passed through by zksolc.
        "storageLayout": {/* ... */},
        // Optional: Transient storage layout (object).
        // Corresponds to "transientStorageLayout" in the outputSelection settings.
        // Provided by solc and passed through by zksolc.
        "transientStorageLayout": {/* ... */},
        // Optional: Developer documentation (natspec object).
        // Corresponds to "devdoc" in the outputSelection settings.
        // Provided by solc and passed through by zksolc.
        "devdoc": {/* ... */},
        // Optional: User documentation (natspec object).
        // Corresponds to "userdoc" in the outputSelection settings.
        // Provided by solc and passed through by zksolc.
        "userdoc": {/* ... */},
        // Optional: Contract metadata (object).
        // Corresponds to "metadata" in the outputSelection settings.
        // Provided by solc and wrapped with additional data by zksolc.
        "metadata": {/* ... */},
        // Optional: Yul produced by solc (string).
        // Corresponds to "irOptimized" in the outputSelection settings.
        // Provided by solc and passed through by zksolc.
        "irOptimized": "/* ... */",
        // Required: EraVM target outputs.
        "eravm": {
          // Required: EraVM bytecode (string).
          "bytecode": "0000008003000039000000400030043f0000000100200190000000130000c13d...",
          // Optional: EraVM assembly produced by zksolc (string).
          // Corresponds to "eravm.assembly" in the outputSelection settings.
          "assembly": "/* ... */"
        },
        // Required: EVM target outputs.
        // Warning: EraVM artifacts "bytecode" and "assembly" are still returned here within the "evm" object for backward compatibility, but all new applications must be reading from the "eravm" object.
        "evm": {
          // Required, Deprecated(EraVM): EVM bytecode.
          "bytecode": {
            // Required: Bytecode (string).
            "object": "0000008003000039000000400030043f0000000100200190000000130000c13d..."
          },
          // Optional: List of function hashes (object).
          // Corresponds to "evm.methodIdentifiers" in the outputSelection settings.
          // Provided by solc and passed through by zksolc.
          "methodIdentifiers": {
            // Mapping between the function signature and its hash.
            "delegate(address)": "5c19a95c"
          },
          // Optional: EVM assembly produced by solc (object).
          // Corresponds to "evm.legacyAssembly" in the outputSelection settings.
          // Provided by solc and passed through by zksolc.
          "legacyAssembly": {/* ... */},

          // Optional, Deprecated: EraVM assembly produced by zksolc (string).
          // Corresponds to "eravm.assembly" in the outputSelection settings.
          "assembly": "/* ... */"
        },

        // Required, zksolc(eravm): Bytecode hash.
        // Used to identify bytecode on ZKsync chains.
        "hash": "5ab89dcf...",
        // Required, zksolc(eravm): All factory dependencies, both linked and unlinked.
        // This field is useful if the full list of dependencies is needed, including those that could not have been linked yet.
        // Example: [ "default.sol:Test" ].
        "factoryDependenciesUnlinked": [/* ... */],
        // Required, zksolc(eravm): Mapping between bytecode hashes and full contract identifiers.
        // Only linked contracts are listed here due to the requirement of bytecode hash.
        // Example: { "5ab89dcf...": "default.sol:Test" }.
        "factoryDependencies": {/* ... */},
        // Required, zksolc(eravm): Mapping between full contract identifiers and library identifiers that must be linked after compilation.
        // Only unlinked libraries are listed here.
        // Example: { "default.sol:Test": "library.sol:Library" }.
        "missingLibraries": {/* ... */},
        // Required, zksolc: Binary object format.
        // Tells whether the bytecode has been linked.
        // Possible values: "elf" (unlinked), "raw" (linked).
        "objectFormat": "elf"
      }
    }
  },

  // Optional: Unset if no messages were emitted.
  "errors": [
    {
      // Optional: Location within the source file.
      // Unset if the error is unrelated to input sources.
      "sourceLocation": {
        /// Required: The source path.
        "file": "sourceFile.sol",
        /// Required: The source location start. Equals -1 if unknown.
        "start": 0,
        /// Required: The source location end. Equals -1 if unknown.
        "end": 100
      },
      // Required: Message type.
      // zksolc only produces "Error" and "Warning" types.
      // *solc* are listed at https://docs.soliditylang.org/en/latest/using-the-compiler.html#error-types.
      "type": "Error",
      // Required: Component the error originates from.
      // zksolc only produces "general".
      // *solc* may produce other values as well.
      "component": "general",
      // Required: Message severity.
      // zksolc only produces "Error" and "Warning" types.
      // *solc* "error", "warning" or "info". May be extended in the future.
      "severity": "error",
      // Optional: Unique code for the cause of the error.
      // Only *solc* produces error codes for now.
      // zksolc error classification is coming soon.
      "errorCode": "3141",
      // Required: Message.
      "message": "Invalid keyword",
      // Required: Message formatted using the source location.
      "formattedMessage": "sourceFile.sol:100: Invalid keyword"
    }
  ],

  // Required: Short semver-compatible solc compiler version.
  "version": "0.8.28",
  // Required: Full solc compiler version.
  "long_version": "0.8.28+commit.7893614a.Darwin.appleclang",
  // Required: Short semver-compatible zksolc compiler version.
  "zk_version": "1.5.8",
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="combined-json"><a class="header" href="#combined-json">Combined JSON</a></h1>
<p>Combined JSON is an I/O mode designed to provide a middle-ground experience between basic CLI and standard JSON. In this mode, input data is provided by the user via CLI, and JSON output can be easily read by both humans and programs calling <em>zksolc</em> as a child process.</p>
<h2 id="usage-1"><a class="header" href="#usage-1">Usage</a></h2>
<p>To use combined JSON, pass the <code>--combined-json</code> flag to <em>zksolc</em> with the desired comma-separated output selectors:</p>
<pre><code class="language-shell">zksolc './MyContract.sol' --combined-json 'ast,abi,metadata'
</code></pre>
<p>The following selectors are supported:</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Selector</th><th style="text-align: left">Description</th><th style="text-align: left">Type</th><th style="text-align: left">Origin</th></tr></thead><tbody>
<tr><td style="text-align: left"><strong>abi</strong></td><td style="text-align: left">Solidity ABI</td><td style="text-align: left">JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>hashes</strong></td><td style="text-align: left">Solidity function hashes</td><td style="text-align: left">JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>metadata</strong></td><td style="text-align: left">Metadata</td><td style="text-align: left">Stringified JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>devdoc</strong></td><td style="text-align: left">Developer documentation</td><td style="text-align: left">JSON (NatSpec)</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>userdoc</strong></td><td style="text-align: left">User documentation</td><td style="text-align: left">JSON (NatSpec)</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>storage-layout</strong></td><td style="text-align: left">Solidity storage layout</td><td style="text-align: left">JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>transient-storage-layout</strong></td><td style="text-align: left">Solidity transientstorage layout</td><td style="text-align: left">JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>ast</strong></td><td style="text-align: left">AST of the source file</td><td style="text-align: left">JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>asm</strong></td><td style="text-align: left">EVM assembly</td><td style="text-align: left">JSON</td><td style="text-align: left"><strong>solc</strong></td></tr>
<tr><td style="text-align: left"><strong>eravm-assembly</strong></td><td style="text-align: left">EraVM assembly</td><td style="text-align: left">String</td><td style="text-align: left"><strong>zksolc</strong></td></tr>
<tr><td style="text-align: left"><strong>bin</strong></td><td style="text-align: left">Deploy ytecode (always enabled)</td><td style="text-align: left">Hexadecimal string</td><td style="text-align: left"><strong>zksolc</strong></td></tr>
<tr><td style="text-align: left"><strong>bin-runtime</strong></td><td style="text-align: left">Runtime bytecode (EVM-only, always enabled)</td><td style="text-align: left">Hexadecimal string</td><td style="text-align: left"><strong>zksolc</strong></td></tr>
</tbody></table>
</div>
<blockquote>
<p><strong>Warning:</strong> It is only possible to use Combined JSON with Solidity input, so the path to <strong>solc</strong> must be always provided to <strong>zksolc</strong>. Support for other languages is planned for future releases.</p>
</blockquote>
<h2 id="output-format"><a class="header" href="#output-format">Output Format</a></h2>
<p>The format below is a modification of the original combined JSON <a href="https://docs.soliditylang.org/en/latest/using-the-compiler.html#output-description">output</a> format implemented by <em>solc</em>. It means that there are:</p>
<ul>
<li><em>zksolc</em>-specific options that are not present in the original format: they are marked as <em>zksolc</em> in the specification below.</li>
<li><em>solc</em>-specific options that are not supported by <em>zksolc</em>: they are not mentioned in the specification below.</li>
</ul>
<pre><code class="language-javascript">{
  // Required: Contract outputs.
  "contracts": {
    "MyContract.sol:Test": {
      // Optional: Emitted if "hashes" selector is provided.
      "hashes": {/* ... */},
      // Optional: Emitted if "abi" selector is provided.
      "abi": [/* ... */],
      // Optional: Emitted if "metadata" selector is provided.
      "metadata": "/* ... */",
      // Optional: Emitted if "devdoc" selector is provided.
      "devdoc": {/* ... */},
      // Optional: Emitted if "userdoc" selector is provided.
      "userdoc": {/* ... */},
      // Optional: Emitted if "storage-layout" selector is provided.
      "storage-layout": {/* ... */},
      // Optional: Emitted if "transient-storage-layout" selector is provided.
      "transient-storage-layout": {/* ... */},
      // Optional: Emitted if "ast" selector is provided.
      "ast": {/* ... */},
      // Optional: Emitted if "asm" selector is provided.
      "asm": {/* ... */},

      // Optional: Emitted if "assembly" selector is provided.
      "assembly": "/* ... */",
      // Required: Bytecode is always emitted.
      "bin": "0000008003000039000000400030043f0000000100200190000000130000c13d...",
      // Required: Bytecode is always emitted.
      "bin-runtime": "0000008003000039000000400030043f0000000100200190000000130000c13d...",

      // Required, zksolc(eravm): All factory dependencies, both linked and unlinked.
      // This field is useful if the full list of dependencies is needed, including those that could not have been linked yet.
      // Example: [ "default.sol:Test" ].
      "factory-deps-unlinked": [/* ... */],
      // Required, zksolc(eravm): Mapping between bytecode hashes and full contract identifiers.
      // Only linked contracts are listed here due to the requirement of bytecode hash.
      // Example: { "5ab89dcf...": "default.sol:Test" }.
      "factory-deps": {/* ... */},
      // Required, zksolc(eravm): Unlinked EraVM libraries.
      // Example: [ "library.sol:Library" ].
      "missing-libraries": [/* ... */],
      // Required, zksolc: Binary object format.
      // Tells whether the bytecode has been linked.
      // Possible values: "elf" (unlinked), "raw" (linked).
      "object-format": "elf"
    }
  },
  // Optional: List of input files.
  // Only emitted if "ast" selector is provided.
  "sourceList": [
    "MyContract.sol"
  ],
  // Optional: List of input sources.
  // Only emitted if "ast" selector is provided.
  "sources": {
    "MyContract.sol": {
      // Required: Contract AST.
      "AST": {/* ... */}
      // Required: Contract index in "sourceList".
      "id": 0
    }
  },
  // Required: Version of solc.
  "version": "0.8.28+commit.acc7d8f9.Darwin.appleclang",
  // Required, zksolc: Version of zksolc.
  "zk_version": "1.5.8"
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="linker"><a class="header" href="#linker">Linker</a></h1>
<p><em>zksolc</em> includes an LLVM-based linker that can be used for post-compile-time library linking.</p>
<p>For unlinked bytecode, the ZKsync compiler toolchain uses <a href="https://en.wikipedia.org/wiki/Executable_and_Linkable_Format">an ELF wrapper</a>, which is the standard in the LLVM framework. ELF-wrapped bytecode cannot be deployed to the blockchain as-is; all library references must first be resolved. Once they are resolved, the ELF wrapper is stripped, leaving only the raw bytecode ready for deployment. This approach also results in unlinked and linked bytecode differing in size.</p>
<blockquote>
<p>When compiling to EraVM, provide all build artifacts to the linker. Unlike EVM ones, EraVM dependencies are linked using the bytecode hash, so the linker must be able to derive the bytecode hash of all contracts in order to automatically resolve all dependencies.</p>
</blockquote>
<p>The <em>zksolc</em> linker can be used in several ways:</p>
<ul>
<li><a href="05-linker.html#json-protocol">JSON Protocol</a></li>
<li><a href="05-linker.html#basic-cli">Basic CLI</a></li>
</ul>
<h2 id="json-protocol"><a class="header" href="#json-protocol">JSON Protocol</a></h2>
<p>This mode is suitable for integration with tooling such as Foundry. The linker features its own JSON protocol with input and output formats which are described in <a href="05-linker.html#input">input</a> and <a href="05-linker.html#output">output</a> sections below.</p>
<p>Input JSON can be provided by-value via the <code>--standard-json</code> option:</p>
<pre><code class="language-shell">zksolc --link --standard-json './input.json'
</code></pre>
<p>Alternatively, the input JSON can be fed to <em>zksolc</em> via <em>stdin</em>:</p>
<pre><code class="language-shell">cat './input.json' | zksolc --link --standard-json
</code></pre>
<h3 id="input"><a class="header" href="#input">Input</a></h3>
<pre><code class="language-javascript">{
  // Input bytecode files mapping.
  "bytecodes": {
    // Input bytecode must be a valid ELF object.
    "tests/data/bytecodes/linker.zbin": "7f454c46010101ff000000000000000001000401010000000000000000000000..."
  },
  // Library specifiers array.
  "libraries": [
    // The format is following that of solc: "filename:libraryName=address".
    "Greeter.sol:GreeterHelper=0x1234567890abcdef1234567890abcdef12345678"
  ]
}
</code></pre>
<h3 id="output"><a class="header" href="#output">Output</a></h3>
<pre><code class="language-javascript">{
  // Bytecode files where all library references have been successfully resolved.
  "linked": {
    "tests/data/bytecodes/linked.zbin": {
      // Linked EraVM bytecode, stripped of the ELF wrapper.
      "bytecode": "0000008003000039000000400030043f0000000100200190000000130000c13d...",
      // Hash of the bytecode used to identify EraVM dependencies during deployment.
      "hash": "010000d5bf4dd6262304eb67a95a76e6e4b0e9f1dc3d2c524c129c6464939407",
      // Resolved library specifiers.
      "linker_symbols": [
        // The format is following that of solc: "libraryPath:libraryName".
        "Greeter.sol:GreeterHelper"
      ],
      // Resolved factory dependency (CREATE/CREATE2) specifiers.
      "factory_dependencies": [
        // The format is "contractPath:contractName".
        // Dependencies are resolved automatically if all bytecode objects are passed to the linker.
        "Dependency.sol:GreeterDependency"
      ]
    }
  },
  // Lists of unresolved symbols, such as those not provided to the linker.
  // The linker caller must add the missing specifiers and call the linker again.
  "unlinked": {
    "tests/data/bytecodes/linker.zbin": {
      // Unresolved library specifiers.
      "linker_symbols": [
        // The format is following that of solc: "libraryPath:libraryName".
        "Greeter.sol:GreeterHelper"
      ],
      // Unresolved factory dependency (CREATE/CREATE2) specifiers.
      "factory_dependencies": [
        // The format is "contractPath:contractName".
        // Dependencies are resolved automatically if all bytecode objects are passed to the linker.
        "Dependency.sol:GreeterDependency"
      ]
    }
  },
  // Linked raw bytecode files that do not require linking, so they were not processed in the current call.
  "ignored": {
    "tests/data/bytecodes/ignored.zbin": {
      // Linked raw EraVM bytecode.
      "bytecode": "0000008003000039000000400030043f0000000100200190000000130000c13d...",
      // Hash of the bytecode used to identify EraVM dependencies during deployment.
      "hash": "010000d5bf4dd6262304eb67a95abcdefc3d2c524c129c6464939407"
    }
  }
}
</code></pre>
<h2 id="basic-cli-1"><a class="header" href="#basic-cli-1">Basic CLI</a></h2>
<p>This mode is suitable for experiments and quick checks. Linking is done in several steps:</p>
<ol>
<li>A contract with a library dependency is compiled to bytecode:</li>
</ol>
<pre><code class="language-solidity">// SPDX-License-Identifier: Unlicensed

pragma solidity ^0.8.0;

library GreeterHelper {
    function addPrefix(Greeter greeter, string memory great) public view returns (string memory) {
        return string.concat(greeter._prefix(), great);
    }
}

contract Greeter {
    string public greeting;
    string public _prefix;

    constructor(string memory _greeting) {
        greeting = _greeting;
        _prefix = "The greating is:";
    }

    function greet() public view returns (string memory) {
        return GreeterHelper.addPrefix(this, greeting);
    }
}
</code></pre>
<pre><code class="language-bash">zksolc './Greeter.sol' --output-dir './output' --bin
</code></pre>
<ol start="2">
<li>Check for unlinked library and factory dependency references.</li>
</ol>
<p>It can be done with the following command, where the <code>--library</code> argument is intentionally omitted:</p>
<pre><code class="language-bash">zksolc --link './output/Greeter.sol/Greeter.zbin'
</code></pre>
<p>Output:</p>
<pre><code class="language-json">{
  "linked": {},
  "unlinked": {
    "./output/Greeter.sol/Greeter.zbin": {
      "linker_symbols": ["Greeter.sol:GreeterHelper"],
      "factory_dependencies": []
    }
  },
  "ignored": {}
}
</code></pre>
<ol start="3">
<li>Provide library addresses to the linker.</li>
</ol>
<p>The library addresses must be provided in the <code>--libraries</code> argument:</p>
<pre><code class="language-bash">zksolc --link './output/Greeter.sol/Greeter.zbin' --libraries 'Greeter.sol:GreeterHelper=0x1234567812345678123456781234567812345678'
</code></pre>
<p>Output:</p>
<pre><code class="language-json">{
  "linked": {
    "./output/Greeter.sol/Greeter.zbin": {
      "bytecode": "0000008003000039000000400030043f0000000100200190000000130000c13d...",
      "hash": "010000bd2bcef5602ae1ebc0b812cc65d88655a8d972ac10227f142e1838093c",
      "linker_symbols": ["Greeter.sol:GreeterHelper"],
      "factory_dependencies": []
    }
  },
  "unlinked": {},
  "ignored": {}
}
</code></pre>
<p>If you run the last command above once again, nothing will happen, and the previously linked file will show up as <code>ignored</code>:</p>
<pre><code class="language-json">{
  "linked": {},
  "unlinked": {},
  "ignored": {
    "./output/Greeter.sol/Greeter.zbin": {
      "bytecode": "0000008003000039000000400030043f0000000100200190000000130000c13d...",
      "hash": "010000bd2bcef5602ae1ebc0b812cc65d88655a8d972ac10227f142e1838093c"
    }
  }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eravm-target-compilation-specification"><a class="header" href="#eravm-target-compilation-specification">EraVM Target Compilation Specification</a></h1>
<p>This is a technical deep dive into the specifics of compiling for the EraVM target.</p>
<p>The deep dive outlines concepts, modules, and terms used in the EraVM target compilation process, such as:</p>
<ul>
<li><a href="eravm/./01-code-separation.html">Code Separation</a></li>
<li><a href="eravm/./02-evm-assembly-translator.html">EVM Assembly Translator</a></li>
<li><a href="eravm/./03-system-contracts.html">System Contracts</a></li>
<li><a href="eravm/./04-exception-handling.html">Exception Handling</a></li>
</ul>
<p>The following sections provide a detailed specification of compilation of each individual instruction:</p>
<ul>
<li><a href="eravm/./05-instructions/01-reference.html">Instructions</a></li>
<li><a href="eravm/./06-extensions.html">Extensions</a></li>
</ul>
<p>Finally, this document describes the binary layout of EraVM bytecode:</p>
<ul>
<li><a href="eravm/./07-binary-layout.html">Binary Layout</a></li>
</ul>
<h2 id="glossary"><a class="header" href="#glossary">Glossary</a></h2>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left">Term</th><th style="text-align: left">Definition</th></tr></thead><tbody>
<tr><td style="text-align: left">zksolc</td><td style="text-align: left">Solidity compiler developed by Matter Labs.</td></tr>
<tr><td style="text-align: left">solc</td><td style="text-align: left">High-level Solidity compiler developed by the Ethereum community. Called by zksolc to get IRs and other auxiliary data.</td></tr>
<tr><td style="text-align: left">LLVM</td><td style="text-align: left">The world's most popular and powerful compiler framework, used for optimizations and assembly generation.</td></tr>
<tr><td style="text-align: left">Assembler</td><td style="text-align: left">Tool that translates assembly to bytecode.</td></tr>
<tr><td style="text-align: left">Linker</td><td style="text-align: left">Tool that links dependencies, such as libraries, before final bytecode can be emitted.</td></tr>
<tr><td style="text-align: left">Virtual Machine</td><td style="text-align: left">ZKsync Era virtual machine with a custom instruction set.</td></tr>
<tr><td style="text-align: left">EraVM Specification</td><td style="text-align: left">A combination of human readable documentation and formal description of EraVM, including its structure, semantics, and encoding.</td></tr>
<tr><td style="text-align: left">IR</td><td style="text-align: left">Intermediate representation used by the compiler internally to represent source code.</td></tr>
<tr><td style="text-align: left">Yul</td><td style="text-align: left">One of two Solidity IRs. A superset of assembly available in Solidity. Used by default for contracts written in Solidity ≥0.8.</td></tr>
<tr><td style="text-align: left">EVM Assembly</td><td style="text-align: left">One of two Solidity IRs. A predecessor of Yul that is closer to EVM bytecode. Used by default for contracts written in Solidity &lt;0.8.</td></tr>
<tr><td style="text-align: left">LLVM IR</td><td style="text-align: left">IR native to the LLVM framework.</td></tr>
<tr><td style="text-align: left">EraVM Assembly</td><td style="text-align: left">Text representation of EraVM bytecode. Emitted by the LLVM framework. Translated into EraVM bytecode by the EraVM assembler.</td></tr>
<tr><td style="text-align: left">EraVM Bytecode</td><td style="text-align: left">Contract bytecode executed by EraVM.</td></tr>
<tr><td style="text-align: left">Stack</td><td style="text-align: left">Segment of non-persistent contract memory. Consists of two parts: global data and function stack frame.</td></tr>
<tr><td style="text-align: left">Heap</td><td style="text-align: left">Segment of non-persistent contract memory. Allocation is handled by the solc’s allocator only.</td></tr>
<tr><td style="text-align: left">Auxiliary heap</td><td style="text-align: left">Segment of non-persistent contract memory. Introduced to avoid conflicts with the solc’s allocator.</td></tr>
<tr><td style="text-align: left">Calldata</td><td style="text-align: left">Segment of non-persistent contract memory. Heap or auxiliary heap of the parent/caller contract.</td></tr>
<tr><td style="text-align: left">Return data</td><td style="text-align: left">Segment of non-persistent contract memory. Heap or auxiliary heap of the child/callee contract.</td></tr>
<tr><td style="text-align: left">Storage</td><td style="text-align: left">Persistent contract memory with no important differences from that of EVM.</td></tr>
<tr><td style="text-align: left">Transient storage</td><td style="text-align: left">Transient contract memory with no important differences from that of EVM.</td></tr>
<tr><td style="text-align: left">System contracts</td><td style="text-align: left">Set of ZKsync kernel contracts written in Solidity by Matter Labs.</td></tr>
<tr><td style="text-align: left">Contract context</td><td style="text-align: left">Storage of the VM keeping data such as current address, caller’s address, block timestamp, etc.</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="code-separation"><a class="header" href="#code-separation">Code Separation</a></h1>
<p>In both EVM and EraVM, contract bytecode is divided into two segments: deploy and runtime. The deploy code — also known as the constructor — runs only once when the contract is first deployed. In contrast, the runtime code executes every time the contract is called.</p>
<p>However, on EraVM, both segments are deployed together rather than split into two separate chunks. The constructor is simply added to the contract as a standard public function, which the System Contracts invoke during deployment.</p>
<p>Just like on the EVM, the deploy code on EraVM takes the form of a single constructor. Our compiler merges this constructor into the runtime code while generating LLVM IR, as illustrated in the minimal example below.</p>
<h2 id="llvm-ir"><a class="header" href="#llvm-ir">LLVM IR</a></h2>
<p>In the EraVM subset of LLVM IR, the <code>@__entry</code> function’s arguments <code>%0</code> through <code>%11</code> correspond to EraVM registers <code>r1</code> through <code>r12</code>.</p>
<p>Specifically, register <code>r2</code> maps to the argument <code>%1</code>. This register contains a bit that indicates whether the call is for deploy code, and that flag is used to branch between deploy and runtime code blocks.</p>
<pre><code class="language-llvm">define i256 @__entry(ptr addrspace(3) nocapture readnone %0, i256 %1, i256 %2, i256 %3, i256 %4, i256 %5, i256 %6, i256 %7, i256 %8, i256 %9, i256 %10, i256 %11) local_unnamed_addr #1 personality ptr @__personality {
entry:
  %is_deploy_code_call_flag_truncated = and i256 %1, 1                                                          ; check if the call is a deploy code call
  %is_deploy_code_call_flag.not = icmp eq i256 %is_deploy_code_call_flag_truncated, 0                           ; invert the flag
  br i1 %is_deploy_code_call_flag.not, label %runtime_code_call_block, label %deploy_code_call_block            ; branch to the deploy code block if the flag is set

deploy_code_call_block:                           ; preds = %entry
  store i256 32, ptr addrspace(2) inttoptr (i256 256 to ptr addrspace(2)), align 256                            ; store the offset of the array of immutables
  store i256 0, ptr addrspace(2) inttoptr (i256 288 to ptr addrspace(2)), align 32                              ; store the length of the array of immutables
  tail call void @llvm.eravm.return(i256 53919893334301279589334030174039261352344891250716429051063678533632) ; return the array of immutables using EraVM return ABI data encoding
  unreachable

runtime_code_call_block:                          ; preds = %entry
  store i256 42, ptr addrspace(1) null, align 4294967296                                                        ; store a value to return
  tail call void @llvm.eravm.return(i256 2535301200456458802993406410752)                                      ; return the value using EraVM return ABI data encoding
  unreachable
}
</code></pre>
<h2 id="eravm-assembly"><a class="header" href="#eravm-assembly">EraVM Assembly</a></h2>
<p>In EraVM assembly, the branching logic appears as follows:</p>
<pre><code class="language-asm">__entry:
.func_begin0:
	and!	    1, r2, r0
	jump.ne	  @.BB0_1
	add	      r0, r0, r1
	retl	    @DEFAULT_FAR_RETURN
.BB0_1:
	add	32,   r0, r1
	stm.ah	  256, r1
	stm.ah	  288, r0
	add	      code[@CPI0_0], r0, r1
	retl	    @DEFAULT_FAR_RETURN
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-assembly-translator"><a class="header" href="#evm-assembly-translator">EVM Assembly Translator</a></h1>
<p>Our toolchain uses two Solidity code generators:</p>
<div class="table-wrapper"><table><thead><tr><th>Name</th><th><strong>solc</strong> support</th><th><strong>solc</strong> default</th></tr></thead><tbody>
<tr><td>EVM Assembly</td><td>&gt;=0.4.12</td><td>&lt;0.8</td></tr>
<tr><td>Yul</td><td>&gt;=0.8.0</td><td>&gt;=0.8</td></tr>
</tbody></table>
</div>
<h2 id="zksync-fork-of-solc"><a class="header" href="#zksync-fork-of-solc">ZKsync Fork of <em>solc</em></a></h2>
<p>EVM assembly is challenging to translate to LLVM IR because it obscures the contract’s control flow and relies heavily on dynamic jumps.</p>
<p><em>solc</em>'s EVM assembly representation introduces several challenges for our LLVM IR translator:</p>
<ol>
<li>Internal function pointers are stored in memory or storage, then dynamically loaded and called.</li>
<li>Each iteration of local recursion allocates an additional stack frame.</li>
<li>Some try-catch patterns leave values on the stack, complicating stack analysis.</li>
</ol>
<p>All of these issues have been resolved in <a href="https://github.com/matter-labs/era-solidity">our fork of <em>solc</em></a>, where we removed dynamic jumps and added the necessary metadata in the code generation process.</p>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>In this and the following sections, you will find a minimal example of a Solidity contract, its EVM assembly, and its translation to LLVM IR, which is then compiled into EraVM bytecode.</p>
<pre><code class="language-solidity">contract Example {
  function main() public pure returns (uint256 result) {
    result = 42;
  }
}
</code></pre>
<h2 id="evm-legacy-assembly"><a class="header" href="#evm-legacy-assembly">EVM Legacy Assembly</a></h2>
<p>Produced by <strong>solc</strong> v0.7.6.</p>
<pre><code class="language-txt">| Line | Instruction  | Value/Tag |
| ---- | ------------ | --------- |
| 000  | PUSH         | 80        |
| 001  | PUSH         | 40        |
| 002  | MSTORE       |           |
| 003  | CALLVALUE    |           |
| 004  | DUP1         |           |
| 005  | ISZERO       |           |
| 006  | PUSH         | [tag] 1   |
| 007  | JUMPI        |           |
| 008  | PUSH         | 0         |
| 009  | DUP1         |           |
| 010  | REVERT       |           |
| 011  | Tag 1        |           |
| 012  | JUMPDEST     |           |
| 013  | POP          |           |
| 014  | PUSH         | 4         |
| 015  | CALLDATASIZE |           |
| 016  | LT           |           |
| 017  | PUSH         | [tag] 2   |
| 018  | JUMPI        |           |
| 019  | PUSH         | 0         |
| 020  | CALLDATALOAD |           |
| 021  | PUSH         | E0        |
| 022  | SHR          |           |
| 023  | DUP1         |           |
| 024  | PUSH         | 5A8AC02D  |
| 025  | EQ           |           |
| 026  | PUSH         | [tag] 3   |
| 027  | JUMPI        |           |
| 028  | Tag 2        |           |
| 029  | JUMPDEST     |           |
| 030  | PUSH         | 0         |
| 031  | DUP1         |           |
| 032  | REVERT       |           |
| 033  | Tag 3        |           |
| 034  | JUMPDEST     |           |
| 035  | PUSH         | [tag] 4   |
| 036  | PUSH         | [tag] 5   |
| 037  | JUMP         | [in]      |
| 038  | Tag 4        |           |
| 039  | JUMPDEST     |           |
| 040  | PUSH         | 40        |
| 041  | DUP1         |           |
| 042  | MLOAD        |           |
| 043  | SWAP2        |           |
| 044  | DUP3         |           |
| 045  | MSTORE       |           |
| 046  | MLOAD        |           |
| 047  | SWAP1        |           |
| 048  | DUP2         |           |
| 049  | SWAP1        |           |
| 050  | SUB          |           |
| 051  | PUSH         | 20        |
| 052  | ADD          |           |
| 053  | SWAP1        |           |
| 054  | RETURN       |           |
| 055  | Tag 5        |           |
| 056  | JUMPDEST     |           |
| 057  | PUSH         | 2A        |
| 058  | SWAP1        |           |
| 059  | JUMP         | [out]     |
</code></pre>
<h2 id="ethir"><a class="header" href="#ethir">EthIR</a></h2>
<p>EthIR (Ethereal IR) is an intermediate representation developed specifically for our translator. It serves several key purposes:</p>
<ol>
<li>Tracking the stack state to identify jump destinations.</li>
<li>Duplicating blocks that are reachable from predecessors with different stack states.</li>
<li>Reconstructing the complete control-flow graph of the contract using the aforementioned data.</li>
<li>Resolving dependencies and static data chunks.</li>
</ol>
<p>Meaning of EthIR data:</p>
<ol>
<li><code>V_&lt;name&gt;</code> - a value returned by an instruction.</li>
<li><code>T_&lt;tag&gt;</code> - the tag of an assembly block.</li>
<li><code>40</code> - a hexadecimal constant.</li>
<li><code>tests/solidity/simple/default.sol:Test</code> - a contract full path definition.</li>
</ol>
<p>Stack legend format: <code>[ &lt;current_1&gt; | &lt;current_2&gt; | ... | &lt;current_N&gt; ] - [ &lt;popped_1&gt; | &lt;popped_2&gt; | ... | &lt;popped_N&gt; ] + [ &lt;pushed_1&gt; | &lt;pushed_2&gt; | ... | &lt;pushed_N&gt; ]</code>.</p>
<pre><code class="language-text">// The default entry function of the contract.
function main {
// The maximum stack size in the function.
    stack_usage: 6
block_dt_0/0:                           // Deploy Code Tag 0, Instance 0.
// PUSHed 0x80 onto the stack.
    PUSH           80                                                               [  ] + [ 80 ]
// PUSHed 0x40 onto the stack.
    PUSH           40                                                               [ 80 ] + [ 40 ]
// POPped 0x40 at 0x80 from the stack to store 0x80 at 0x40.
    MSTORE                                                                          [  ] - [ 80 | 40 ]
// PUSHed CALLVALUE onto the stack.
    CALLVALUE                                                                       [  ] + [ V_CALLVALUE ]
    DUP1                                                                            [ V_CALLVALUE ] + [ V_CALLVALUE ]
    ISZERO                                                                          [ V_CALLVALUE ] - [ V_CALLVALUE ] + [ V_ISZERO ]
    PUSH [tag]     1                                                                [ V_CALLVALUE | V_ISZERO ] + [ T_1 ]
// JUMPI schedules rt_0/0 for analysis with the current stack state.
    JUMPI                                                                           [ V_CALLVALUE ] - [ V_ISZERO | T_1 ]
    PUSH           0                                                                [ V_CALLVALUE ] + [ 0 ]
    DUP1                                                                            [ V_CALLVALUE | 0 ] + [ 0 ]
    REVERT                                                                          [ V_CALLVALUE ] - [ 0 | 0 ]
block_dt_1/0: (predecessors: dt_0/0)    // Deploy Code Tag 1, Instance 0; the only predecessor of this block is dt_0/0.
// JUMPDESTs are ignored as we are only interested in the stack state and tag destinations.
    JUMPDEST                                                                        [ V_CALLVALUE ]
    POP                                                                             [  ] - [ V_CALLVALUE ]
    PUSH #[$]      tests/solidity/simple/default.sol:Test                           [  ] + [ tests/solidity/simple/default.sol:Test ]
    DUP1                                                                            [ tests/solidity/simple/default.sol:Test ] + [ tests/solidity/simple/default.sol:Test ]
    PUSH [$]       tests/solidity/simple/default.sol:Test                           [ tests/solidity/simple/default.sol:Test | tests/solidity/simple/default.sol:Test ] + [ tests/solidity/simple/default.sol:Test ]
    PUSH           0                                                                [ tests/solidity/simple/default.sol:Test | tests/solidity/simple/default.sol:Test | tests/solidity/simple/default.sol:Test ] + [ 0 ]
    CODECOPY                                                                        [ tests/solidity/simple/default.sol:Test ] - [ tests/solidity/simple/default.sol:Test | tests/solidity/simple/default.sol:Test | 0 ]
    PUSH           0                                                                [ tests/solidity/simple/default.sol:Test ] + [ 0 ]
    RETURN                                                                          [  ] - [ tests/solidity/simple/default.sol:Test | 0 ]
// The runtime code is analyzed in the same control-flow graph as the deploy code, as it is possible to call its functions from the constructor.
block_rt_0/0:                           // Deploy Code Tag 0, Instance 0.
    PUSH           80                                                               [  ] + [ 80 ]
    PUSH           40                                                               [ 80 ] + [ 40 ]
    MSTORE                                                                          [  ] - [ 80 | 40 ]
    CALLVALUE                                                                       [  ] + [ V_CALLVALUE ]
    DUP1                                                                            [ V_CALLVALUE ] + [ V_CALLVALUE ]
    ISZERO                                                                          [ V_CALLVALUE ] - [ V_CALLVALUE ] + [ V_ISZERO ]
    PUSH [tag]     1                                                                [ V_CALLVALUE | V_ISZERO ] + [ T_1 ]
    JUMPI                                                                           [ V_CALLVALUE ] - [ V_ISZERO | T_1 ]
    PUSH           0                                                                [ V_CALLVALUE ] + [ 0 ]
    DUP1                                                                            [ V_CALLVALUE | 0 ] + [ 0 ]
    REVERT                                                                          [ V_CALLVALUE ] - [ 0 | 0 ]
block_rt_1/0: (predecessors: rt_0/0)    // Runtime Code Tag 1, Instance 0; the only predecessor of this block is rt_0/0.
    JUMPDEST                                                                        [ V_CALLVALUE ]
    POP                                                                             [  ] - [ V_CALLVALUE ]
    PUSH           4                                                                [  ] + [ 4 ]
    CALLDATASIZE                                                                    [ 4 ] + [ V_CALLDATASIZE ]
    LT                                                                              [  ] - [ 4 | V_CALLDATASIZE ] + [ V_LT ]
    PUSH [tag]     2                                                                [ V_LT ] + [ T_2 ]
    JUMPI                                                                           [  ] - [ V_LT | T_2 ]
    PUSH           0                                                                [  ] + [ 0 ]
    CALLDATALOAD                                                                    [  ] - [ 0 ] + [ V_CALLDATALOAD ]
    PUSH           E0                                                               [ V_CALLDATALOAD ] + [ E0 ]
    SHR                                                                             [  ] - [ V_CALLDATALOAD | E0 ] + [ V_SHR ]
    DUP1                                                                            [ V_SHR ] + [ V_SHR ]
    PUSH           5A8AC02D                                                         [ V_SHR | V_SHR ] + [ 5A8AC02D ]
    EQ                                                                              [ V_SHR ] - [ V_SHR | 5A8AC02D ] + [ V_EQ ]
    PUSH [tag]     3                                                                [ V_SHR | V_EQ ] + [ T_3 ]
    JUMPI                                                                           [ V_SHR ] - [ V_EQ | T_3 ]
    Tag 2                                                                           [ V_SHR ]
// This instance is called with a different stack state using the JUMPI above.
block_rt_2/0: (predecessors: rt_1/0)    // Runtime Code Tag 2, Instance 0.
    JUMPDEST                                                                        [  ]
    PUSH           0                                                                [  ] + [ 0 ]
    DUP1                                                                            [ 0 ] + [ 0 ]
    REVERT                                                                          [  ] - [ 0 | 0 ]
// This instance is also called from rt_1/0, but using a fallthrough 'Tag 2'.
// Given different stack states, we create a new instance of the block operating on different data
// and potentially different tag destinations, although usually such blocks are merged back by LLVM.
block_rt_2/1: (predecessors: rt_1/0)    // Runtime Code Tag 2, Instance 1.
    JUMPDEST                                                                        [ V_SHR ]
    PUSH           0                                                                [ V_SHR ] + [ 0 ]
    DUP1                                                                            [ V_SHR | 0 ] + [ 0 ]
    REVERT                                                                          [ V_SHR ] - [ 0 | 0 ]
block_rt_3/0: (predecessors: rt_1/0)    // Runtime Code Tag 3, Instance 0.
    JUMPDEST                                                                        [ V_SHR ]
    PUSH [tag]     4                                                                [ V_SHR ] + [ T_4 ]
    PUSH [tag]     5                                                                [ V_SHR | T_4 ] + [ T_5 ]
    JUMP           [in]                                                             [ V_SHR | T_4 ] - [ T_5 ]
block_rt_4/0: (predecessors: rt_5/0)    // Runtime Code Tag 4, Instance 0.
    JUMPDEST                                                                        [ V_SHR | 2A ]
    PUSH           40                                                               [ V_SHR | 2A ] + [ 40 ]
    DUP1                                                                            [ V_SHR | 2A | 40 ] + [ 40 ]
    MLOAD                                                                           [ V_SHR | 2A | 40 ] - [ 40 ] + [ V_MLOAD ]
    SWAP2                                                                           [ V_SHR | V_MLOAD | 40 | 2A ]
    DUP3                                                                            [ V_SHR | V_MLOAD | 40 | 2A ] + [ V_MLOAD ]
    MSTORE                                                                          [ V_SHR | V_MLOAD | 40 ] - [ 2A | V_MLOAD ]
    MLOAD                                                                           [ V_SHR | V_MLOAD ] - [ 40 ] + [ V_MLOAD ]
    SWAP1                                                                           [ V_SHR | V_MLOAD | V_MLOAD ]
    DUP2                                                                            [ V_SHR | V_MLOAD | V_MLOAD ] + [ V_MLOAD ]
    SWAP1                                                                           [ V_SHR | V_MLOAD | V_MLOAD | V_MLOAD ]
    SUB                                                                             [ V_SHR | V_MLOAD ] - [ V_MLOAD | V_MLOAD ] + [ V_SUB ]
    PUSH           20                                                               [ V_SHR | V_MLOAD | V_SUB ] + [ 20 ]
    ADD                                                                             [ V_SHR | V_MLOAD ] - [ V_SUB | 20 ] + [ V_ADD ]
    SWAP1                                                                           [ V_SHR | V_ADD | V_MLOAD ]
    RETURN                                                                          [ V_SHR ] - [ V_ADD | V_MLOAD ]
block_rt_5/0: (predecessors: rt_3/0)    // Runtime Code Tag 5, Instance 0.
    JUMPDEST                                                                        [ V_SHR | T_4 ]
    PUSH           2A                                                               [ V_SHR | T_4 ] + [ 2A ]
    SWAP1                                                                           [ V_SHR | 2A | T_4 ]
// JUMP [out] is usually a return statement
    JUMP           [out]                                                            [ V_SHR | 2A ] - [ T_4 ]
</code></pre>
<h3 id="unoptimized-llvm-ir"><a class="header" href="#unoptimized-llvm-ir">Unoptimized LLVM IR</a></h3>
<p>In LLVM IR, the required stack space is allocated at the start of the <code>main</code> function, and every stack operation uses a statically known stack pointer with an offset derived from EthIR.</p>
<pre><code class="language-llvm">; Function Attrs: nofree null_pointer_is_valid
define i256 @__entry(ptr addrspace(3) %0, i256 %1, i256 %2, i256 %3, i256 %4, i256 %5, i256 %6, i256 %7, i256 %8, i256 %9, i256 %10, i256 %11) #7 personality ptr @__personality {
entry:
  store ptr addrspace(3) %0, ptr @ptr_calldata, align 32
  %abi_pointer_value = ptrtoint ptr addrspace(3) %0 to i256
  %abi_pointer_value_shifted = lshr i256 %abi_pointer_value, 96
  %abi_length_value = and i256 %abi_pointer_value_shifted, 4294967295
  store i256 %abi_length_value, ptr @calldatasize, align 32
  %calldatasize = load i256, ptr @calldatasize, align 32
  %ptr_calldata = load ptr addrspace(3), ptr @ptr_calldata, align 32
  %calldata_end_pointer = getelementptr i8, ptr addrspace(3) %ptr_calldata, i256 %calldatasize
  store ptr addrspace(3) %calldata_end_pointer, ptr @ptr_return_data, align 32
  store ptr addrspace(3) %calldata_end_pointer, ptr @ptr_decommit, align 32
  %calldatasize1 = load i256, ptr @calldatasize, align 32
  %ptr_calldata2 = load ptr addrspace(3), ptr @ptr_calldata, align 32
  %calldata_end_pointer3 = getelementptr i8, ptr addrspace(3) %ptr_calldata2, i256 %calldatasize1
  store ptr addrspace(3) %calldata_end_pointer3, ptr @ptr_active, align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 1), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 2), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 3), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 4), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 5), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 6), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 7), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 8), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 9), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 10), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 11), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 12), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 13), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 14), align 32
  store ptr addrspace(3) %calldata_end_pointer3, ptr getelementptr inbounds ([16 x ptr addrspace(3)], ptr @ptr_active, i256 0, i256 15), align 32
  store i256 %1, ptr @call_flags, align 32
  store i256 %2, ptr @extra_abi_data, align 32
  store i256 %3, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 1), align 32
  store i256 %4, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 2), align 32
  store i256 %5, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 3), align 32
  store i256 %6, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 4), align 32
  store i256 %7, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 5), align 32
  store i256 %8, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 6), align 32
  store i256 %9, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 7), align 32
  store i256 %10, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 8), align 32
  store i256 %11, ptr getelementptr inbounds ([10 x i256], ptr @extra_abi_data, i256 0, i32 9), align 32
  %is_deploy_code_call_flag_truncated = and i256 %1, 1
  %is_deploy_code_call_flag = icmp eq i256 %is_deploy_code_call_flag_truncated, 1
  br i1 %is_deploy_code_call_flag, label %deploy_code_call_block, label %runtime_code_call_block

return:                                           ; preds = %runtime_code_call_block, %deploy_code_call_block
  ret i256 0

deploy_code_call_block:                           ; preds = %entry
  call void @__deploy()
  br label %return

runtime_code_call_block:                          ; preds = %entry
  call void @__runtime()
  br label %return
}

; Function Attrs: nofree null_pointer_is_valid
define private void @__deploy() #7 personality ptr @__personality {
entry:
  call void @main(i1 true)
  br label %return

return:                                           ; preds = %entry
  ret void
}

; Function Attrs: nofree null_pointer_is_valid
define private void @__runtime() #7 personality ptr @__personality {
entry:
  call void @main(i1 false)
  br label %return

return:                                           ; preds = %entry
  ret void
}

; Function Attrs: nofree null_pointer_is_valid
define private void @main(i1 %0) #7 personality ptr @__personality {
entry:
  %stack_var_000 = alloca i256, align 32
  store i256 0, ptr %stack_var_000, align 32
  %stack_var_001 = alloca i256, align 32
  store i256 0, ptr %stack_var_001, align 32
  %stack_var_002 = alloca i256, align 32
  store i256 0, ptr %stack_var_002, align 32
  %stack_var_003 = alloca i256, align 32
  store i256 0, ptr %stack_var_003, align 32
  %stack_var_004 = alloca i256, align 32
  store i256 0, ptr %stack_var_004, align 32
  %stack_var_005 = alloca i256, align 32
  store i256 0, ptr %stack_var_005, align 32
  %stack_var_006 = alloca i256, align 32
  store i256 0, ptr %stack_var_006, align 32
  br i1 %0, label %"block_dt_0/0", label %"block_rt_0/0"

return:                                           ; No predecessors!
  ret void

"block_dt_0/0":                                   ; preds = %entry
  store i256 128, ptr %stack_var_000, align 32
  store i256 64, ptr %stack_var_001, align 32
  %argument_0 = load i256, ptr %stack_var_001, align 32
  %argument_1 = load i256, ptr %stack_var_000, align 32
  %memory_store_pointer = inttoptr i256 %argument_0 to ptr addrspace(1)
  store i256 %argument_1, ptr addrspace(1) %memory_store_pointer, align 1
  %get_u128_value = call i256 @llvm.eravm.getu128()
  store i256 %get_u128_value, ptr %stack_var_000, align 32
  %dup1 = load i256, ptr %stack_var_000, align 32
  store i256 %dup1, ptr %stack_var_001, align 32
  %argument_01 = load i256, ptr %stack_var_001, align 32
  %comparison_result = icmp eq i256 %argument_01, 0
  %comparison_result_extended = zext i1 %comparison_result to i256
  store i256 %comparison_result_extended, ptr %stack_var_001, align 32
  store i256 1, ptr %stack_var_002, align 32
  %conditional_dt_1_condition = load i256, ptr %stack_var_001, align 32
  %conditional_dt_1_condition_compared = icmp ne i256 %conditional_dt_1_condition, 0
  br i1 %conditional_dt_1_condition_compared, label %"block_dt_1/0", label %conditional_dt_1_join_block

"block_dt_1/0":                                   ; preds = %"block_dt_0/0"
  store i256 2, ptr %stack_var_000, align 32
  br label %"block_dt_2/0"

"block_dt_2/0":                                   ; preds = %"block_dt_1/0"
  store i256 0, ptr %stack_var_000, align 32
  %dup14 = load i256, ptr %stack_var_000, align 32
  store i256 %dup14, ptr %stack_var_001, align 32
  store i256 0, ptr %stack_var_002, align 32
  store i256 0, ptr %stack_var_003, align 32
  %argument_05 = load i256, ptr %stack_var_003, align 32
  %argument_16 = load i256, ptr %stack_var_002, align 32
  %argument_2 = load i256, ptr %stack_var_001, align 32
  %calldata_copy_destination_pointer = inttoptr i256 %argument_05 to ptr addrspace(1)
  %calldata_pointer = load ptr addrspace(3), ptr @ptr_calldata, align 32
  %calldata_source_pointer = getelementptr i8, ptr addrspace(3) %calldata_pointer, i256 %argument_16
  call void @llvm.memcpy.p1.p3.i256(ptr addrspace(1) align 1 %calldata_copy_destination_pointer, ptr addrspace(3) align 1 %calldata_source_pointer, i256 %argument_2, i1 false)
  store i256 0, ptr %stack_var_001, align 32
  %argument_07 = load i256, ptr %stack_var_001, align 32
  %argument_18 = load i256, ptr %stack_var_000, align 32
  store i256 32, ptr addrspace(2) inttoptr (i256 256 to ptr addrspace(2)), align 1
  store i256 0, ptr addrspace(2) inttoptr (i256 288 to ptr addrspace(2)), align 1
  call void @__return(i256 256, i256 64, i256 2)
  unreachable

"block_rt_0/0":                                   ; preds = %entry
  store i256 128, ptr %stack_var_000, align 32
  store i256 64, ptr %stack_var_001, align 32
  %argument_09 = load i256, ptr %stack_var_001, align 32
  %argument_110 = load i256, ptr %stack_var_000, align 32
  %memory_store_pointer11 = inttoptr i256 %argument_09 to ptr addrspace(1)
  store i256 %argument_110, ptr addrspace(1) %memory_store_pointer11, align 1
  %get_u128_value12 = call i256 @llvm.eravm.getu128()
  store i256 %get_u128_value12, ptr %stack_var_000, align 32
  %dup113 = load i256, ptr %stack_var_000, align 32
  store i256 %dup113, ptr %stack_var_001, align 32
  %argument_014 = load i256, ptr %stack_var_001, align 32
  %comparison_result15 = icmp eq i256 %argument_014, 0
  %comparison_result_extended16 = zext i1 %comparison_result15 to i256
  store i256 %comparison_result_extended16, ptr %stack_var_001, align 32
  store i256 1, ptr %stack_var_002, align 32
  %conditional_rt_1_condition = load i256, ptr %stack_var_001, align 32
  %conditional_rt_1_condition_compared = icmp ne i256 %conditional_rt_1_condition, 0
  br i1 %conditional_rt_1_condition_compared, label %"block_rt_1/0", label %conditional_rt_1_join_block

"block_rt_1/0":                                   ; preds = %"block_rt_0/0"
  store i256 4, ptr %stack_var_000, align 32
  %calldatasize = load i256, ptr @calldatasize, align 32
  store i256 %calldatasize, ptr %stack_var_001, align 32
  %argument_019 = load i256, ptr %stack_var_001, align 32
  %argument_120 = load i256, ptr %stack_var_000, align 32
  %comparison_result21 = icmp ult i256 %argument_019, %argument_120
  %comparison_result_extended22 = zext i1 %comparison_result21 to i256
  store i256 %comparison_result_extended22, ptr %stack_var_000, align 32
  store i256 2, ptr %stack_var_001, align 32
  %conditional_rt_2_condition = load i256, ptr %stack_var_000, align 32
  %conditional_rt_2_condition_compared = icmp ne i256 %conditional_rt_2_condition, 0
  br i1 %conditional_rt_2_condition_compared, label %"block_rt_2/0", label %conditional_rt_2_join_block

"block_rt_2/0":                                   ; preds = %"block_rt_1/0"
  store i256 0, ptr %stack_var_000, align 32
  store i256 0, ptr %stack_var_001, align 32
  %argument_032 = load i256, ptr %stack_var_001, align 32
  %argument_133 = load i256, ptr %stack_var_000, align 32
  call void @__revert(i256 %argument_032, i256 %argument_133, i256 0)
  unreachable

"block_rt_2/1":                                   ; preds = %conditional_rt_3_join_block
  store i256 0, ptr %stack_var_001, align 32
  store i256 0, ptr %stack_var_002, align 32
  %argument_034 = load i256, ptr %stack_var_002, align 32
  %argument_135 = load i256, ptr %stack_var_001, align 32
  call void @__revert(i256 %argument_034, i256 %argument_135, i256 0)
  unreachable

"block_rt_3/0":                                   ; preds = %conditional_rt_2_join_block
  store i256 4, ptr %stack_var_001, align 32
  store i256 5, ptr %stack_var_002, align 32
  br label %"block_rt_5/0"

"block_rt_4/0":                                   ; preds = %"block_rt_6/0"
  store i256 64, ptr %stack_var_002, align 32
  %argument_036 = load i256, ptr %stack_var_002, align 32
  %memory_load_pointer = inttoptr i256 %argument_036 to ptr addrspace(1)
  %memory_load_result = load i256, ptr addrspace(1) %memory_load_pointer, align 1
  store i256 %memory_load_result, ptr %stack_var_002, align 32
  %dup137 = load i256, ptr %stack_var_002, align 32
  store i256 %dup137, ptr %stack_var_003, align 32
  %dup3 = load i256, ptr %stack_var_001, align 32
  store i256 %dup3, ptr %stack_var_004, align 32
  %dup2 = load i256, ptr %stack_var_003, align 32
  store i256 %dup2, ptr %stack_var_005, align 32
  %argument_038 = load i256, ptr %stack_var_005, align 32
  %argument_139 = load i256, ptr %stack_var_004, align 32
  %memory_store_pointer40 = inttoptr i256 %argument_038 to ptr addrspace(1)
  store i256 %argument_139, ptr addrspace(1) %memory_store_pointer40, align 1
  store i256 32, ptr %stack_var_004, align 32
  %argument_041 = load i256, ptr %stack_var_004, align 32
  %argument_142 = load i256, ptr %stack_var_003, align 32
  %addition_result = add i256 %argument_041, %argument_142
  store i256 %addition_result, ptr %stack_var_003, align 32
  %swap2_top_value = load i256, ptr %stack_var_003, align 32
  %swap2_swap_value = load i256, ptr %stack_var_001, align 32
  store i256 %swap2_swap_value, ptr %stack_var_003, align 32
  store i256 %swap2_top_value, ptr %stack_var_001, align 32
  store i256 64, ptr %stack_var_002, align 32
  %argument_043 = load i256, ptr %stack_var_002, align 32
  %memory_load_pointer44 = inttoptr i256 %argument_043 to ptr addrspace(1)
  %memory_load_result45 = load i256, ptr addrspace(1) %memory_load_pointer44, align 1
  store i256 %memory_load_result45, ptr %stack_var_002, align 32
  %dup146 = load i256, ptr %stack_var_002, align 32
  store i256 %dup146, ptr %stack_var_003, align 32
  %swap2_top_value47 = load i256, ptr %stack_var_003, align 32
  %swap2_swap_value48 = load i256, ptr %stack_var_001, align 32
  store i256 %swap2_swap_value48, ptr %stack_var_003, align 32
  store i256 %swap2_top_value47, ptr %stack_var_001, align 32
  %argument_049 = load i256, ptr %stack_var_003, align 32
  %argument_150 = load i256, ptr %stack_var_002, align 32
  %subtraction_result = sub i256 %argument_049, %argument_150
  store i256 %subtraction_result, ptr %stack_var_002, align 32
  %swap1_top_value = load i256, ptr %stack_var_002, align 32
  %swap1_swap_value = load i256, ptr %stack_var_001, align 32
  store i256 %swap1_swap_value, ptr %stack_var_002, align 32
  store i256 %swap1_top_value, ptr %stack_var_001, align 32
  %argument_051 = load i256, ptr %stack_var_002, align 32
  %argument_152 = load i256, ptr %stack_var_001, align 32
  call void @__return(i256 %argument_051, i256 %argument_152, i256 0)
  unreachable

"block_rt_5/0":                                   ; preds = %"block_rt_3/0"
  store i256 0, ptr %stack_var_002, align 32
  store i256 42, ptr %stack_var_003, align 32
  %swap1_top_value53 = load i256, ptr %stack_var_003, align 32
  %swap1_swap_value54 = load i256, ptr %stack_var_002, align 32
  store i256 %swap1_swap_value54, ptr %stack_var_003, align 32
  store i256 %swap1_top_value53, ptr %stack_var_002, align 32
  %dup155 = load i256, ptr %stack_var_002, align 32
  store i256 %dup155, ptr %stack_var_003, align 32
  br label %"block_rt_6/0"

"block_rt_6/0":                                   ; preds = %"block_rt_5/0"
  %swap1_top_value56 = load i256, ptr %stack_var_002, align 32
  %swap1_swap_value57 = load i256, ptr %stack_var_001, align 32
  store i256 %swap1_swap_value57, ptr %stack_var_002, align 32
  store i256 %swap1_top_value56, ptr %stack_var_001, align 32
  br label %"block_rt_4/0"

conditional_dt_1_join_block:                      ; preds = %"block_dt_0/0"
  store i256 0, ptr %stack_var_001, align 32
  store i256 0, ptr %stack_var_002, align 32
  %argument_02 = load i256, ptr %stack_var_002, align 32
  %argument_13 = load i256, ptr %stack_var_001, align 32
  call void @__revert(i256 %argument_02, i256 %argument_13, i256 0)
  unreachable

conditional_rt_1_join_block:                      ; preds = %"block_rt_0/0"
  store i256 0, ptr %stack_var_001, align 32
  store i256 0, ptr %stack_var_002, align 32
  %argument_017 = load i256, ptr %stack_var_002, align 32
  %argument_118 = load i256, ptr %stack_var_001, align 32
  call void @__revert(i256 %argument_017, i256 %argument_118, i256 0)
  unreachable

conditional_rt_2_join_block:                      ; preds = %"block_rt_1/0"
  store i256 0, ptr %stack_var_000, align 32
  %argument_023 = load i256, ptr %stack_var_000, align 32
  %calldata_pointer24 = load ptr addrspace(3), ptr @ptr_calldata, align 32
  %calldata_pointer_with_offset = getelementptr i8, ptr addrspace(3) %calldata_pointer24, i256 %argument_023
  %calldata_value = load i256, ptr addrspace(3) %calldata_pointer_with_offset, align 32
  store i256 %calldata_value, ptr %stack_var_000, align 32
  store i256 224, ptr %stack_var_001, align 32
  %argument_025 = load i256, ptr %stack_var_001, align 32
  %argument_126 = load i256, ptr %stack_var_000, align 32
  %shr_call = call i256 @__shr(i256 %argument_025, i256 %argument_126)
  store i256 %shr_call, ptr %stack_var_000, align 32
  %dup127 = load i256, ptr %stack_var_000, align 32
  store i256 %dup127, ptr %stack_var_001, align 32
  store i256 3758009808, ptr %stack_var_002, align 32
  %argument_028 = load i256, ptr %stack_var_002, align 32
  %argument_129 = load i256, ptr %stack_var_001, align 32
  %comparison_result30 = icmp eq i256 %argument_028, %argument_129
  %comparison_result_extended31 = zext i1 %comparison_result30 to i256
  store i256 %comparison_result_extended31, ptr %stack_var_001, align 32
  store i256 3, ptr %stack_var_002, align 32
  %conditional_rt_3_condition = load i256, ptr %stack_var_001, align 32
  %conditional_rt_3_condition_compared = icmp ne i256 %conditional_rt_3_condition, 0
  br i1 %conditional_rt_3_condition_compared, label %"block_rt_3/0", label %conditional_rt_3_join_block

conditional_rt_3_join_block:                      ; preds = %conditional_rt_2_join_block
  store i256 2, ptr %stack_var_001, align 32
  br label %"block_rt_2/1"
}

attributes #0 = { cold noreturn nounwind }
attributes #1 = { nocallback nofree nounwind willreturn memory(argmem: readwrite) }
attributes #2 = { nocallback nofree nosync nounwind willreturn memory(none) }
attributes #3 = { nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #4 = { nounwind }
attributes #5 = { nounwind willreturn memory(none) }
attributes #6 = { nomerge nounwind willreturn memory(inaccessiblemem: readwrite) }
attributes #7 = { nofree null_pointer_is_valid }
</code></pre>
<h3 id="optimized-llvm-ir"><a class="header" href="#optimized-llvm-ir">Optimized LLVM IR</a></h3>
<p>LLVM optimizes away the redundancy, resulting in the LLVM IR shown below.</p>
<pre><code class="language-llvm">; Function Attrs: nofree noreturn null_pointer_is_valid
define i256 @__entry(ptr addrspace(3) %0, i256 %1, i256 %2, i256 %3, i256 %4, i256 %5, i256 %6, i256 %7, i256 %8, i256 %9, i256 %10, i256 %11) local_unnamed_addr #1 personality ptr @__personality {
entry:
  %is_deploy_code_call_flag_truncated = and i256 %1, 1
  %is_deploy_code_call_flag.not = icmp eq i256 %is_deploy_code_call_flag_truncated, 0
  store i256 128, ptr addrspace(1) inttoptr (i256 64 to ptr addrspace(1)), align 64
  %get_u128_value.i.i4 = tail call i256 @llvm.eravm.getu128()
  br i1 %is_deploy_code_call_flag.not, label %runtime_code_call_block, label %deploy_code_call_block

deploy_code_call_block:                           ; preds = %entry
  %comparison_result.i.i = icmp eq i256 %get_u128_value.i.i4, 0
  br i1 %comparison_result.i.i, label %"block_dt_1/0.i.i", label %"block_rt_2/0.i.i"

"block_dt_1/0.i.i":                               ; preds = %deploy_code_call_block
  store i256 32, ptr addrspace(2) inttoptr (i256 256 to ptr addrspace(2)), align 256
  store i256 0, ptr addrspace(2) inttoptr (i256 288 to ptr addrspace(2)), align 32
  tail call void @llvm.eravm.return(i256 53919893334301279589334030174039261352344891250716429051063678533632)
  unreachable

"block_rt_2/0.i.i":                               ; preds = %runtime_code_call_block, %conditional_rt_2_join_block.i.i, %deploy_code_call_block
  tail call void @llvm.eravm.revert(i256 0)
  unreachable

runtime_code_call_block:                          ; preds = %entry
  %abi_pointer_value = ptrtoint ptr addrspace(3) %0 to i256
  %comparison_result.i.i5 = icmp ne i256 %get_u128_value.i.i4, 0
  %12 = and i256 %abi_pointer_value, 340282366604025813406317257057592410112
  %comparison_result21.i.i = icmp eq i256 %12, 0
  %or.cond.i = select i1 %comparison_result.i.i5, i1 true, i1 %comparison_result21.i.i
  br i1 %or.cond.i, label %"block_rt_2/0.i.i", label %conditional_rt_2_join_block.i.i

"block_rt_3/0.i.i":                               ; preds = %conditional_rt_2_join_block.i.i
  store i256 42, ptr addrspace(1) inttoptr (i256 128 to ptr addrspace(1)), align 128
  tail call void @llvm.eravm.return(i256 2535301202817642044428229017600)
  unreachable

conditional_rt_2_join_block.i.i:                  ; preds = %runtime_code_call_block
  %calldata_value.i.i = load i256, ptr addrspace(3) %0, align 32
  %shift_res.i.mask.i.i = and i256 %calldata_value.i.i, -26959946667150639794667015087019630673637144422540572481103610249216
  %comparison_result30.i.i = icmp eq i256 %shift_res.i.mask.i.i, -14476345239007179661737236217584162293203948892620596377535322027150077329408
  br i1 %comparison_result30.i.i, label %"block_rt_3/0.i.i", label %"block_rt_2/0.i.i"
}

; Function Attrs: noreturn nounwind
declare void @llvm.eravm.revert(i256) #2

; Function Attrs: noreturn nounwind
declare void @llvm.eravm.return(i256) #2

attributes #0 = { mustprogress nofree nosync nounwind willreturn memory(none) }
attributes #1 = { nofree noreturn null_pointer_is_valid }
attributes #2 = { noreturn nounwind }
</code></pre>
<h3 id="eravm-assembly-1"><a class="header" href="#eravm-assembly-1">EraVM Assembly</a></h3>
<p>The optimized LLVM IR is then compiled into EraVM assembly, resulting in a bytecode size comparable to that produced via the Yul pipeline.</p>
<pre><code class="language-asm">        .text
        .file   "test.sol:Example"
        .globl  __entry
__entry:
.func_begin0:
        add     128, r0, r3
        stm.h   64, r3
        ldvl    r3
        and!    1, r2, r0
        jump.ne @.BB0_1
        sub!    r3, r0, r0
        jump.ne @.BB0_2
        and!    code[@CPI0_1], r1, r0
        jump.eq @.BB0_2
        ldp     r1, r1
        and     code[@CPI0_2], r1, r1
        sub.s!  code[@CPI0_3], r1, r0
        jump.ne @.BB0_2
        add     42, r0, r1
        stm.h   128, r1
        add     code[@CPI0_4], r0, r1
        retl    @DEFAULT_FAR_RETURN
.BB0_1:
        sub!    r3, r0, r0
        jump.ne @.BB0_2
        add     32, r0, r1
        stm.ah  256, r1
        stm.ah  288, r0
        add     code[@CPI0_0], r0, r1
        retl    @DEFAULT_FAR_RETURN
.BB0_2:
        add     r0, r0, r1
        revl    @DEFAULT_FAR_REVERT
.func_end0:

        .rodata
CPI0_0:
        .cell   53919893334301279589334030174039261352344891250716429051063678533632
CPI0_1:
        .cell   340282366604025813406317257057592410112
CPI0_2:
        .cell   -26959946667150639794667015087019630673637144422540572481103610249216
CPI0_3:
        .cell   -14476345239007179661737236217584162293203948892620596377535322027150077329408
CPI0_4:
        .cell   2535301202817642044428229017600
        .text
DEFAULT_UNWIND:
        pncl    @DEFAULT_UNWIND
DEFAULT_FAR_RETURN:
        retl    @DEFAULT_FAR_RETURN
DEFAULT_FAR_REVERT:
        revl    @DEFAULT_FAR_REVERT
</code></pre>
<p>For comparison, the Yul pipeline of <em>solc</em> v0.8.28 generates the following EraVM assembly:</p>
<pre><code class="language-asm">        .text
        .file   "test.sol:Example"
        .globl  __entry
__entry:
.func_begin0:
        add     128, r0, r3
        stm.h   64, r3
        and!    1, r2, r0
        jump.ne @.BB0_1
        and!    code[@CPI0_1], r1, r0
        jump.eq @.BB0_7
        ldp     r1, r1
        and     code[@CPI0_2], r1, r1
        sub.s!  code[@CPI0_3], r1, r0
        jump.ne @.BB0_7
        ldvl    r1
        sub!    r1, r0, r0
        jump.ne @.BB0_7
        add     42, r0, r1
        stm.h   128, r1
        add     code[@CPI0_4], r0, r1
        retl    @DEFAULT_FAR_RETURN
.BB0_1:
        ldvl    r1
        sub!    r1, r0, r0
        jump.ne @.BB0_7
        add     32, r0, r1
        stm.ah  256, r1
        stm.ah  288, r0
        add     code[@CPI0_0], r0, r1
        retl    @DEFAULT_FAR_RETURN
.BB0_7:
        add     r0, r0, r1
        revl    @DEFAULT_FAR_REVERT
.func_end0:

        .rodata
CPI0_0:
        .cell   53919893334301279589334030174039261352344891250716429051063678533632
CPI0_1:
        .cell   340282366604025813406317257057592410112
CPI0_2:
        .cell   -26959946667150639794667015087019630673637144422540572481103610249216
CPI0_3:
        .cell   -14476345239007179661737236217584162293203948892620596377535322027150077329408
CPI0_4:
        .cell   2535301202817642044428229017600
        .text
DEFAULT_UNWIND:
        pncl    @DEFAULT_UNWIND
DEFAULT_FAR_RETURN:
        retl    @DEFAULT_FAR_RETURN
DEFAULT_FAR_REVERT:
        revl    @DEFAULT_FAR_REVERT
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="system-contracts"><a class="header" href="#system-contracts">System Contracts</a></h1>
<p>Many EVM instructions require special handling by the System Contracts. The full detailed list of instructions that require special
handling is provided at <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions">the EVM instructions reference</a>.</p>
<p>There are several types of System Contracts from the perspective of how they are handled by <strong>zksolc</strong>:</p>
<ol>
<li><a href="eravm/03-system-contracts.html#environmental-data-storage">Environmental data storage</a>.</li>
<li><a href="eravm/03-system-contracts.html#keccak256-hash-function">KECCAK256 hash function</a>.</li>
<li><a href="eravm/03-system-contracts.html#contract-deployer">Contract deployer</a>.</li>
<li><a href="eravm/03-system-contracts.html#ether-value-simulator">Ether value simulator</a>.</li>
<li><a href="eravm/03-system-contracts.html#simulator-of-immutables">Simulator of immutables</a>.</li>
<li><a href="eravm/03-system-contracts.html#event-handler">Event handler</a>.</li>
</ol>
<h3 id="environmental-data-storage"><a class="header" href="#environmental-data-storage">Environmental Data Storage</a></h3>
<p>Such storage contracts are accessed with static calls in order to retrieve values for the block, transaction, and other
environmental entities: <code>CHAINID</code>, <code>DIFFICULTY</code>, <code>BLOCKHASH</code>, etc.</p>
<p>One good example of such contract is
<a href="https://github.com/matter-labs/era-contracts/blob/main/system-contracts/contracts/SystemContext.sol">SystemContext</a> that provides
the majority of the environmental data.</p>
<p>Since EVM is not using external calls for these instructions, we must use <a href="eravm/03-system-contracts.html#auxiliary-heap">the auxiliary heap</a> for
their calldata.</p>
<p>Steps to handle such instructions:</p>
<ol>
<li>Store the calldata for the System Contract call on the auxiliary heap.</li>
<li>Call the System Contract with a static call.</li>
<li>Check the return status code of the call.</li>
<li><a href="eravm/./04-exception-handling.html">Revert or throw</a> if the status code is zero.</li>
<li>Read the ABI data and extract the result. All such System Contracts return a single 256-bit value.</li>
<li>Return the value as the result of the EVM instruction.</li>
</ol>
<h3 id="keccak256-hash-function"><a class="header" href="#keccak256-hash-function">KECCAK256 Hash Function</a></h3>
<p>Handling of this function is similar to <a href="eravm/03-system-contracts.html#environmental-data-storage">Environmental Data Storage</a> with one key difference: because the EVM also uses heap memory to store the calldata for <code>KECCAK256</code>, the IR generator allocates the required memory chunk, so <strong>zksolc</strong> does not need to use <a href="eravm/03-system-contracts.html#auxiliary-heap">the auxiliary heap</a>.</p>
<h3 id="contract-deployer"><a class="header" href="#contract-deployer">Contract Deployer</a></h3>
<p>See <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#create-create2">handling CREATE</a>
and <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#datasize-dataoffset-datacopy">dependency code substitution instructions</a> on ZKsync Era documentation.</p>
<h3 id="ether-value-simulator"><a class="header" href="#ether-value-simulator">Ether Value Simulator</a></h3>
<p>EraVM does not support passing Ether natively, so this feature is provided by a special System Contract called <a href="https://github.com/matter-labs/era-contracts/blob/main/system-contracts/contracts/MsgValueSimulator.sol">MsgValueSimulator</a>.</p>
<p>An external call is redirected through this simulator if:</p>
<ol>
<li>The <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#call-staticcall-delegatecall">call</a> is ordinary, that is neither static nor delegate.</li>
<li>Its Ether value is non-zero.</li>
</ol>
<p>Calls to the simulator require additional data passed via ABI using registers:</p>
<ol>
<li>Ether value.</li>
<li>The address of the contract to call.</li>
<li>The <a href="https://matter-labs.github.io/eravm-spec/spec.html#to_system">system call bit</a>, set only when redirecting a call to the <a href="eravm/03-system-contracts.html#contract-deployer">ContractDeployer</a>, that is, when <code>CREATE</code> or <code>CREATE2</code> is called with non-zero Ether.</li>
</ol>
<p>To pass Ether in EraVM, the compiler uses:</p>
<ol>
<li>The special 128-bit register <a href="https://matter-labs.github.io/eravm-spec/spec.html#gs_context_u128"><code>context_u128</code></a>
which is a part of the EraVM <a href="https://matter-labs.github.io/eravm-spec/spec.html#StateDefinitions">transient state</a>.</li>
<li>An <a href="https://matter-labs.github.io/eravm-spec/spec.html#ecf_context_u128_value">immutable value of <code>context_u128</code></a>
captured in the stack frame at the moment of the call.</li>
</ol>
<p>Details on setting and capturing this value are covered in the <a href="https://matter-labs.github.io/eravm-spec/spec.html#StateDefinitions">Context Register of the EraVM specification</a>.</p>
<h3 id="simulator-of-immutables"><a class="header" href="#simulator-of-immutables">Simulator of Immutables</a></h3>
<p>Refer to <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#setimmutable-loadimmutable">the handling immutables documentation</a> in ZKsync Era.</p>
<h3 id="event-handler"><a class="header" href="#event-handler">Event Handler</a></h3>
<p>Event payloads are sent to a special System Contract called
<a href="https://github.com/matter-labs/era-contracts/blob/main/system-contracts/contracts/EventWriter.yul">EventWriter</a>. As with EVM, the payload consists of topics and data:</p>
<ol>
<li>Topics with a length prefix are passed via ABI using registers.</li>
<li>Data is passed through the default heap, just like in EVM.</li>
</ol>
<h2 id="auxiliary-heap"><a class="header" href="#auxiliary-heap">Auxiliary Heap</a></h2>
<p><a href="https://matter-labs.github.io/era-compiler-solidity/latest/">zksolc</a> works on <a href="https://docs.zksync.io/zksync-protocol/compiler/toolchain#ir-compilers">the IR level</a>. Because of this, they cannot directly manage the heap memory allocator; that responsibility remains with <a href="https://docs.zksync.io/zksync-protocol/compiler/toolchain#high-level-source-code-compilers">the high-level source code compilers</a> that emit IRs.</p>
<p>However, there are scenarios in which EraVM must allocate memory on the heap while EVM does not, leading to the introduction of the auxiliary heap. The auxiliary heap is used for:</p>
<ol>
<li><a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#setimmutable-loadimmutable">Returning immutables</a> from the constructor.</li>
<li>Allocating calldata and return data for calls to System Contracts.</li>
</ol>
<p>While the ordinary heap contains calldata and return data for calls to <strong>user contracts</strong>, the auxiliary heap holds calldata and return data for calls to <strong>System Contracts</strong>. This preserves EVM compatibility by preventing System Contract calls from affecting calldata or return data, thereby avoiding conflicts with the heap layout that contract developers expect.</p>
<p>For more details on heaps, refer to the EraVM specification, which describes <a href="https://matter-labs.github.io/eravm-spec/spec.html#data_page_params">types of heaps</a>, their connections to <a href="https://matter-labs.github.io/eravm-spec/spec.html#ctx_heap_page_id">stack frames and memory growth</a>, and their role in <a href="https://matter-labs.github.io/eravm-spec/spec.html#MemoryForwarding">contract-to-contract communication</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exception-handling"><a class="header" href="#exception-handling">Exception Handling</a></h1>
<p>This page highlights specific nuances of exception handling (EH) in the EraVM architecture.</p>
<p>In essence, EraVM uses two EH mechanisms: <a href="eravm/04-exception-handling.html#contract-level">contract-level</a> and <a href="eravm/04-exception-handling.html#function-level">function-level</a>. The former is inherited from the EVM architecture, while the latter aligns more closely with general-purpose languages.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: left"></th><th style="text-align: left">Contract Level</th><th style="text-align: left">Function Level</th></tr></thead><tbody>
<tr><td style="text-align: left">Yul Example</td><td style="text-align: left"><code>revert(0, 0)</code></td><td style="text-align: left"><code>verbatim("throw")</code></td></tr>
<tr><td style="text-align: left">Native to</td><td style="text-align: left">EVM</td><td style="text-align: left">General-purpose languages</td></tr>
<tr><td style="text-align: left">Handled by</td><td style="text-align: left">EraVM</td><td style="text-align: left">Compiler</td></tr>
<tr><td style="text-align: left">Caught by</td><td style="text-align: left">Caller contract</td><td style="text-align: left">Caller function</td></tr>
<tr><td style="text-align: left">Efficiency</td><td style="text-align: left">High</td><td style="text-align: left">Low</td></tr>
</tbody></table>
</div>
<h2 id="contract-level"><a class="header" href="#contract-level">Contract Level</a></h2>
<p>This type of exception is inherited from the EVM architecture. In EVM, instructions like <code>REVERT</code> and <code>INVALID</code> immediately terminate the contract’s execution and return control to the callee. It is impossible to catch them within the contract; only the callee can detect them by checking the call status code.</p>
<pre><code class="language-solidity">// callee
revert(0, 0)

// caller
let success = call(...)
if iszero(success) {
    // option 1: rethrow on the contract level
    returndatacopy(...)
    revert(...)

    // option 2: rethrow on the function level
    verbatim("throw") // only available in the Yul mode
}
</code></pre>
<p>EraVM’s behavior is fully equivalent: the VM unwinds the call stack all the way to the contract’s top-level function frame, leaving no possibility to intercept or handle the exception along the way.</p>
<p>These types of exceptions are more efficient, as you can revert at any point of the execution without propagating the exception all the way up.</p>
<h3 id="implementation"><a class="header" href="#implementation">Implementation</a></h3>
<p>In EraVM, contracts invoke one another via <a href="https://matter-labs.github.io/eravm-spec/spec.html#FarCalls">the <code>far_call</code> instruction</a>, which includes <a href="https://matter-labs.github.io/eravm-spec/spec.html#OpFarCall">the exception handler’s address</a> among its arguments.</p>
<h2 id="function-level"><a class="header" href="#function-level">Function Level</a></h2>
<p>This type of exception handling is common in general-purpose languages such as C++. As a result, it integrates naturally into LLVM, even though it is not supported by the smart contract languages our compilers handle. This is also why the two EH mechanisms are treated separately and do not interact within high-level code.</p>
<p>In general-purpose languages, a range of EH operators (e.g. <code>try</code> , <code>throw</code>, and <code>catch</code>) typically indicates which code sections can throw exceptions and how they should be handled. These tools are absent in Solidity and its EVM Yul dialect, so we introduced extensions to the <a href="eravm/./01-extensions.html">EraVM Yul dialect</a> supported by <em>zksolc</em>.</p>
<p>If the contract does not define an EH function named <code>ZKSYNC_CATCH_NEAR_CALL</code>, there is no need to generate <code>catch</code> blocks. Panics will simply propagate to the callee contract by EraVM without any extra overhead.</p>
<p>Several constraints arise from Yul’s structure and the nature of smart contracts:</p>
<ol>
<li>Any function beginning with <code>ZKSYNC_NEAR_CALL</code> is implicitly wrapped with <code>try</code>. If there is an exception handler defined, the following will happen:
<ul>
<li>A panic will be caught by the caller of such function.</li>
<li>Control then transfers to the EH function.</li>
<li>After the EH function finishes, control returns to the caller of <code>ZKSYNC_NEAR_CALL</code>.</li>
</ul>
</li>
<li>Every operation can be considered <code>throw</code>.
<ul>
<li>Any instruction may panic due to out-of-gas, so all instructions can potentially throw.</li>
<li>This reduces optimization opportunities.</li>
</ul>
</li>
<li>The <code>catch</code> block is represented by the <code>ZKSYNC_CATCH_NEAR_CALL</code> function in Yul.
<ul>
<li>A panic in <code>ZKSYNC_NEAR_CALL</code> makes <strong>its caller</strong> catch the exception and call the EH function.</li>
<li>Once the EH function completes, control returns to the caller of <code>ZKSYNC_NEAR_CALL</code>.</li>
</ul>
</li>
<li>Only one EH function is allowed, and it must be named <code>ZKSYNC_CATCH_NEAR_CALL</code>.
<ul>
<li>This approach is not very efficient because every function must include an LLVM IR <code>catch</code> block to capture and propagate exceptions to the EH function.</li>
</ul>
</li>
</ol>
<pre><code class="language-solidity">// Follow the numbers for the order of execution. The call order is:
//     1. caller
//     2. ZKSYNC_NEAR_CALL_callee
//     3. callee_even_deeper
//     4. ZKSYNC_CATCH_NEAR_CALL
//     5. caller

function ZKSYNC_NEAR_CALL_callee() -&gt; value {    // 03
    value := callee_even_deeper()                // 04
}

function callee_even_deeper() -&gt; value {         // 05
    verbatim("throw")                            // 06
}

// Each LLVM IR function automatically includes an implicit 'catch' block,
// which performs the following actions:
//     1. If a return value is expected, keep it zero-initialized ('zero').
//     2. Call the EH function ('ZKSYNC_CATCH_NEAR_CALL').
//     3. Resume execution with the next instruction (e.g., 'value := 42').
function caller() -&gt; value {                      // 01
    let zero := ZKSYNC_NEAR_CALL_callee()         // 02
    value := 42                                   // 09
}

// This handler can also revert execution. Reverts in EH functions cannot be caught,
// so they immediately terminate the execution and return control to the callee contract.
function ZKSYNC_CATCH_NEAR_CALL() {               // 07
    log0(...)                                     // 08
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<p>In this specification, instructions are categorized according to their relevance to the EVM instruction set:</p>
<ul>
<li><a href="eravm/05-instructions/./02-evm/01-reference.html">Native EVM Instructions</a>.</li>
<li><a href="eravm/05-instructions/./03-evm-assembly.html">EVM Assembly Auxiliary Instructions</a>.</li>
<li><a href="eravm/05-instructions/./04-yul.html">Yul Auxiliary Instructions</a>.</li>
</ul>
<p>Most native EVM instructions are represented in both Yul and EVM assembly IRs. When they are not, this is explicitly noted in the instruction description.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-evm-instructions"><a class="header" href="#native-evm-instructions">Native EVM Instructions</a></h1>
<p>EVM instructions are grouped into categories based on <a href="https://www.evm.codes/">the official reference</a>:</p>
<ul>
<li><a href="eravm/05-instructions/02-evm/./02-arithmetic.html">Arithmetic</a></li>
<li><a href="eravm/05-instructions/02-evm/./03-bitwise.html">Bitwise</a></li>
<li><a href="eravm/05-instructions/02-evm/./04-block.html">Block</a></li>
<li><a href="eravm/05-instructions/02-evm/./05-calls.html">Calls</a></li>
<li><a href="eravm/05-instructions/02-evm/./06-create.html">Create</a></li>
<li><a href="eravm/05-instructions/02-evm/./07-environment.html">Environment</a></li>
<li><a href="eravm/05-instructions/02-evm/./08-logging.html">Logging</a></li>
<li><a href="eravm/05-instructions/02-evm/./09-logical.html">Logical</a></li>
<li><a href="eravm/05-instructions/02-evm/./10-memory.html">Memory</a></li>
<li><a href="eravm/05-instructions/02-evm/./11-return.html">Return</a></li>
<li><a href="eravm/05-instructions/02-evm/./12-sha3.html">SHA3</a></li>
<li><a href="eravm/05-instructions/02-evm/./13-stack.html">Stack</a></li>
</ul>
<h3 id="eravm-assembly-2"><a class="header" href="#eravm-assembly-2">EraVM Assembly</a></h3>
<p>The assembly generated for LLVM standard library functions depends on available optimizations, which vary by version. If you do not see an assembly example for a particular instruction, try compiling a reproducing contract using the latest <code>zksolc</code>.</p>
<p>For a comprehensive list of instructions, see the <a href="https://matter-labs.github.io/eravm-spec/spec.html">EraVM specification</a>, which provides them in its table of contents.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arithmetic"><a class="header" href="#arithmetic">Arithmetic</a></h1>
<h2 id="add"><a class="header" href="#add">ADD</a></h2>
<p>Original <a href="https://www.evm.codes/#01?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-1"><a class="header" href="#llvm-ir-1">LLVM IR</a></h3>
<pre><code class="language-llvm">%addition_result = add i256 %value1, %value2
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#add-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-3"><a class="header" href="#eravm-assembly-3">EraVM Assembly</a></h3>
<pre><code class="language-asm">add     r1, r2, r1
</code></pre>
<p>For more detail, see the <a href="https://matter-labs.github.io/eravm-spec/spec.html#AddDefinition">EraVM specification reference</a></p>
<h2 id="mul"><a class="header" href="#mul">MUL</a></h2>
<p>Original <a href="https://www.evm.codes/#02?fork=shanghai">EVM</a> instruction.</p>
<h3 id="differences-from-evm"><a class="header" href="#differences-from-evm">Differences from EVM</a></h3>
<ol>
<li>The carry is written to the 2nd output register</li>
</ol>
<h3 id="llvm-ir-2"><a class="header" href="#llvm-ir-2">LLVM IR</a></h3>
<pre><code class="language-llvm">%multiplication_result = mul i256 %value1, %value2
</code></pre>
<p>EraVM can output the carry of the multiplication operation.
In this case, the result is a tuple of two values: the multiplication result and the carry.
The carry is written to the 2nd output register.
The snippet below returns the carry value.</p>
<pre><code class="language-llvm">%value1_extended = zext i256 %value1 to i512
%value2_extended = zext i256 %value2 to i512
%result_extended = mul nuw i512 %value1_extended, %value2_extended
%result_shifted = lshr i512 %result_extended, 256
%result = trunc i512 %result_shifted to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#mul-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-4"><a class="header" href="#eravm-assembly-4">EraVM Assembly</a></h3>
<pre><code class="language-asm">mul     r1, r2, r1, r2
</code></pre>
<p>For more detail, see the <a href="https://matter-labs.github.io/eravm-spec/spec.html#MulDefinition">EraVM specification reference</a></p>
<h2 id="sub"><a class="header" href="#sub">SUB</a></h2>
<p>Original <a href="https://www.evm.codes/#03?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-3"><a class="header" href="#llvm-ir-3">LLVM IR</a></h3>
<pre><code class="language-llvm">%subtraction_result = sub i256 %value1, %value2
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#sub-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-5"><a class="header" href="#eravm-assembly-5">EraVM Assembly</a></h3>
<pre><code class="language-asm">sub     r1, r2, r1
</code></pre>
<p>For more detail, see the <a href="https://matter-labs.github.io/eravm-spec/spec.html#SubDefinition">EraVM specification reference</a></p>
<h2 id="div"><a class="header" href="#div">DIV</a></h2>
<p>Original <a href="https://www.evm.codes/#04?fork=shanghai">EVM</a> instruction.</p>
<h3 id="differences-from-evm-1"><a class="header" href="#differences-from-evm-1">Differences from EVM</a></h3>
<ol>
<li>The remainder is written to the 2nd output register</li>
</ol>
<h3 id="llvm-ir-4"><a class="header" href="#llvm-ir-4">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__div(i256 %arg1, i256 %arg2) #0 {
entry:
  %is_divider_zero = icmp eq i256 %arg2, 0
  br i1 %is_divider_zero, label %return, label %division

division:
  %div_res = udiv i256 %arg1, %arg2
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ %div_res, %division ]
  ret i256 %res
}
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#udiv-instruction">LLVM IR instruction documentation</a></p>
<p>For more detail, see the <a href="https://matter-labs.github.io/eravm-spec/spec.html#DivDefinition">EraVM specification reference</a></p>
<h2 id="sdiv"><a class="header" href="#sdiv">SDIV</a></h2>
<p>Original <a href="https://www.evm.codes/#05?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-5"><a class="header" href="#llvm-ir-5">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__sdiv(i256 %arg1, i256 %arg2) #0 {
entry:
  %is_divider_zero = icmp eq i256 %arg2, 0
  br i1 %is_divider_zero, label %return, label %division_overflow

division_overflow:
  %is_divided_int_min = icmp eq i256 %arg1, -57896044618658097711785492504343953926634992332820282019728792003956564819968
  %is_minus_one = icmp eq i256 %arg2, -1
  %is_overflow = and i1 %is_divided_int_min, %is_minus_one
  br i1 %is_overflow, label %return, label %division

division:
  %div_res = sdiv i256 %arg1, %arg2
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ %arg1, %division_overflow ], [ %div_res, %division ]
  ret i256 %res
}
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#sdiv-instruction">LLVM IR instruction documentation</a></p>
<p>EraVM does not have a similar instruction.</p>
<h2 id="mod"><a class="header" href="#mod">MOD</a></h2>
<p>Original <a href="https://www.evm.codes/#06?fork=shanghai">EVM</a> instruction.</p>
<h3 id="differences-from-evm-2"><a class="header" href="#differences-from-evm-2">Differences from EVM</a></h3>
<ol>
<li>The remainder is written to the 2nd output register</li>
</ol>
<h3 id="llvm-ir-6"><a class="header" href="#llvm-ir-6">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__mod(i256 %arg1, i256 %arg2) #0 {
entry:
  %is_divider_zero = icmp eq i256 %arg2, 0
  br i1 %is_divider_zero, label %return, label %remainder

remainder:
  %rem_res = urem i256 %arg1, %arg2
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ %rem_res, %remainder ]
  ret i256 %res
}
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#urem-instruction">LLVM IR instruction documentation</a></p>
<p>For more detail, see the <a href="https://matter-labs.github.io/eravm-spec/spec.html#DivDefinition">EraVM specification reference</a></p>
<h2 id="smod"><a class="header" href="#smod">SMOD</a></h2>
<p>Original <a href="https://www.evm.codes/#07?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-7"><a class="header" href="#llvm-ir-7">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__smod(i256 %arg1, i256 %arg2) #0 {
entry:
  %is_divider_zero = icmp eq i256 %arg2, 0
  br i1 %is_divider_zero, label %return, label %division_overflow

division_overflow:
  %is_divided_int_min = icmp eq i256 %arg1, -57896044618658097711785492504343953926634992332820282019728792003956564819968
  %is_minus_one = icmp eq i256 %arg2, -1
  %is_overflow = and i1 %is_divided_int_min, %is_minus_one
  br i1 %is_overflow, label %return, label %remainder

remainder:
  %rem_res = srem i256 %arg1, %arg2
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ 0, %division_overflow ], [ %rem_res, %remainder ]
  ret i256 %res
}
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#srem-instruction">LLVM IR instruction documentation</a></p>
<p>EraVM does not have a similar instruction.</p>
<h2 id="addmod"><a class="header" href="#addmod">ADDMOD</a></h2>
<p>Original <a href="https://www.evm.codes/#08?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-8"><a class="header" href="#llvm-ir-8">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__addmod(i256 %arg1, i256 %arg2, i256 %modulo) #0 {
entry:
  %is_zero = icmp eq i256 %modulo, 0
  br i1 %is_zero, label %return, label %addmod

addmod:
  %arg1m = urem i256 %arg1, %modulo
  %arg2m = urem i256 %arg2, %modulo
  %res = call {i256, i1} @llvm.uadd.with.overflow.i256(i256 %arg1m, i256 %arg2m)
  %sum = extractvalue {i256, i1} %res, 0
  %obit = extractvalue {i256, i1} %res, 1
  %sum.mod = urem i256 %sum, %modulo
  br i1 %obit, label %overflow, label %return

overflow:
  %mod.inv = xor i256 %modulo, -1
  %sum1 = add i256 %sum, %mod.inv
  %sum.ovf = add i256 %sum1, 1
  br label %return

return:
  %value = phi i256 [0, %entry], [%sum.mod, %addmod], [%sum.ovf, %overflow]
  ret i256 %value
}
</code></pre>
<p>EraVM does not have a similar instruction.</p>
<h2 id="mulmod"><a class="header" href="#mulmod">MULMOD</a></h2>
<p>Original <a href="https://www.evm.codes/#09?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-9"><a class="header" href="#llvm-ir-9">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__mulmod(i256 %arg1, i256 %arg2, i256 %modulo) #0 {
entry:
  %cccond = icmp eq i256 %modulo, 0
  br i1 %cccond, label %ccret, label %entrycont

ccret:
  ret i256 0

entrycont:
  %arg1m = urem i256 %arg1, %modulo
  %arg2m = urem i256 %arg2, %modulo
  %less_then_2_128 = icmp ult i256 %modulo, 340282366920938463463374607431768211456
  br i1 %less_then_2_128, label %fast, label %slow

fast:
  %prod = mul i256 %arg1m, %arg2m
  %prodm = urem i256 %prod, %modulo
  ret i256 %prodm

slow:
  %arg1e = zext i256 %arg1m to i512
  %arg2e = zext i256 %arg2m to i512
  %prode = mul i512 %arg1e, %arg2e
  %prodl = trunc i512 %prode to i256
  %prodeh = lshr i512 %prode, 256
  %prodh = trunc i512 %prodeh to i256
  %res = call i256 @__ulongrem(i256 %prodl, i256 %prodh, i256 %modulo)
  ret i256 %res
}
</code></pre>
<p>EraVM does not have a similar instruction.</p>
<h2 id="exp"><a class="header" href="#exp">EXP</a></h2>
<p>Original <a href="https://www.evm.codes/#0a?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-10"><a class="header" href="#llvm-ir-10">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__exp(i256 %value, i256 %exp) "noinline-oz" #0 {
entry:
  %exp_is_non_zero = icmp eq i256 %exp, 0
  br i1 %exp_is_non_zero, label %return, label %exponent_loop_body

return:
  %exp_res = phi i256 [ 1, %entry ], [ %exp_res.1, %exponent_loop_body ]
  ret i256 %exp_res

exponent_loop_body:
  %exp_res.2 = phi i256 [ %exp_res.1, %exponent_loop_body ], [ 1, %entry ]
  %exp_val = phi i256 [ %exp_val_halved, %exponent_loop_body ], [ %exp, %entry ]
  %val_squared.1 = phi i256 [ %val_squared, %exponent_loop_body ], [ %value, %entry ]
  %odd_test = and i256 %exp_val, 1
  %is_exp_odd = icmp eq i256 %odd_test, 0
  %exp_res.1.interm = select i1 %is_exp_odd, i256 1, i256 %val_squared.1
  %exp_res.1 = mul i256 %exp_res.1.interm, %exp_res.2
  %val_squared = mul i256 %val_squared.1, %val_squared.1
  %exp_val_halved = lshr i256 %exp_val, 1
  %exp_val_is_less_2 = icmp ult i256 %exp_val, 2
  br i1 %exp_val_is_less_2, label %return, label %exponent_loop_body
}
</code></pre>
<p>EraVM does not have a similar instruction.</p>
<h2 id="signextend"><a class="header" href="#signextend">SIGNEXTEND</a></h2>
<p>Original <a href="https://www.evm.codes/#0b?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-11"><a class="header" href="#llvm-ir-11">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__signextend(i256 %numbyte, i256 %value) #0 {
entry:
  %is_overflow = icmp uge i256 %numbyte, 31
  br i1 %is_overflow, label %return, label %signextend

signextend:
  %numbit_byte = mul nuw nsw i256 %numbyte, 8
  %numbit = add nsw nuw i256 %numbit_byte, 7
  %numbit_inv = sub i256 256, %numbit
  %signmask = shl i256 1, %numbit
  %valmask = lshr i256 -1, %numbit_inv
  %ext1 = shl i256 -1, %numbit
  %signv = and i256 %signmask, %value
  %sign = icmp ne i256 %signv, 0
  %valclean = and i256 %value, %valmask
  %sext = select i1 %sign, i256 %ext1, i256 0
  %result = or i256 %sext, %valclean
  br label %return

return:
  %signext_res = phi i256 [%value, %entry], [%result, %signextend]
  ret i256 %signext_res
}
</code></pre>
<p>EraVM does not have a similar instruction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h1>
<h2 id="and"><a class="header" href="#and">AND</a></h2>
<p>Original <a href="https://www.evm.codes/#16?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-12"><a class="header" href="#llvm-ir-12">LLVM IR</a></h3>
<pre><code class="language-llvm">%and_result = and i256 %value1, %value2
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#and-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-6"><a class="header" href="#eravm-assembly-6">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
and     r1, r2, r1
st.1    128, r1
</code></pre>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#AndDefinition">EraVM instruction: <code>and</code></a></p>
<h2 id="or"><a class="header" href="#or">OR</a></h2>
<p>Original <a href="https://www.evm.codes/#17?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-13"><a class="header" href="#llvm-ir-13">LLVM IR</a></h3>
<pre><code class="language-llvm">%or_result = or i256 %value1, %value2
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#or-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-7"><a class="header" href="#eravm-assembly-7">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
or      r1, r2, r1
st.1    128, r1
</code></pre>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#AndDefinition">EraVM instruction: <code>or</code></a></p>
<h2 id="xor"><a class="header" href="#xor">XOR</a></h2>
<p>Original <a href="https://www.evm.codes/#18?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-14"><a class="header" href="#llvm-ir-14">LLVM IR</a></h3>
<pre><code class="language-llvm">%xor_result = or i256 %value1, %value2
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#xor-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-8"><a class="header" href="#eravm-assembly-8">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
xor     r1, r2, r1
st.1    128, r1
</code></pre>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#XorDefinition">EraVM instruction: <code>xor</code></a></p>
<h2 id="not"><a class="header" href="#not">NOT</a></h2>
<p>Original <a href="https://www.evm.codes/#19?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-15"><a class="header" href="#llvm-ir-15">LLVM IR</a></h3>
<pre><code class="language-llvm">%xor_result = xor i256 %value, -1
</code></pre>
<h3 id="eravm-assembly-9"><a class="header" href="#eravm-assembly-9">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r1, r1
ld      r1, r1
sub.s   1, r0, r2
xor     r1, r2, r1
st.1    128, r1
</code></pre>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#XorDefinition">EraVM instruction: <code>xor</code></a></p>
<h2 id="byte"><a class="header" href="#byte">BYTE</a></h2>
<p>Original <a href="https://www.evm.codes/#1a?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-16"><a class="header" href="#llvm-ir-16">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__byte(i256 %index, i256 %value) #0 {
entry:
  %is_overflow = icmp ugt i256 %index, 31
  br i1 %is_overflow, label %return, label %extract_byte

extract_byte:
  %bits_offset = shl i256 %index, 3
  %value_shifted_left = shl i256 %value, %bits_offset
  %value_shifted_right = lshr i256 %value_shifted_left, 248
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ %value_shifted_right, %extract_byte ]
  ret i256 %res
}
</code></pre>
<h2 id="shl"><a class="header" href="#shl">SHL</a></h2>
<p>Original <a href="https://www.evm.codes/#1b?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-17"><a class="header" href="#llvm-ir-17">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__shl(i256 %shift, i256 %value) #0 {
entry:
  %is_overflow = icmp ugt i256 %shift, 255
  br i1 %is_overflow, label %return, label %shift_value

shift_value:
  %shift_res = shl i256 %value, %shift
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ %shift_res, %shift_value ]
  ret i256 %res
}
</code></pre>
<h2 id="shr"><a class="header" href="#shr">SHR</a></h2>
<p>Original <a href="https://www.evm.codes/#1c?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-18"><a class="header" href="#llvm-ir-18">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__shr(i256 %shift, i256 %value) #0 {
entry:
  %is_overflow = icmp ugt i256 %shift, 255
  br i1 %is_overflow, label %return, label %shift_value

shift_value:
  %shift_res = lshr i256 %value, %shift
  br label %return

return:
  %res = phi i256 [ 0, %entry ], [ %shift_res, %shift_value ]
  ret i256 %res
}
</code></pre>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#XorDefinition">EraVM instruction: <code>xor</code></a></p>
<h2 id="sar"><a class="header" href="#sar">SAR</a></h2>
<p>Original <a href="https://www.evm.codes/#1d?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-19"><a class="header" href="#llvm-ir-19">LLVM IR</a></h3>
<pre><code class="language-llvm">define i256 @__sar(i256 %shift, i256 %value) #0 {
entry:
  %is_overflow = icmp ugt i256 %shift, 255
  br i1 %is_overflow, label %arith_overflow, label %shift_value

arith_overflow:
  %is_val_positive = icmp sge i256 %value, 0
  %res_overflow = select i1 %is_val_positive, i256 0, i256 -1
  br label %return

shift_value:
  %shift_res = ashr i256 %value, %shift
  br label %return

return:
  %res = phi i256 [ %res_overflow, %arith_overflow ], [ %shift_res, %shift_value ]
  ret i256 %res
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="block"><a class="header" href="#block">Block</a></h1>
<p>This information is requested from a System Contract called <a href="https://github.com/matter-labs/era-system-contracts/blob/main/contracts/SystemContext.sol">SystemContext</a>.</p>
<p>On how the contract is called, see <a href="eravm/05-instructions/02-evm/../../03-system-contracts.html#environmental-data-storage">the relevant section</a>.</p>
<h2 id="blockhash"><a class="header" href="#blockhash">BLOCKHASH</a></h2>
<p>Original <a href="https://www.evm.codes/#40?fork=shanghai">EVM</a> instruction.</p>
<h2 id="coinbase"><a class="header" href="#coinbase">COINBASE</a></h2>
<p>Original <a href="https://www.evm.codes/#41?fork=shanghai">EVM</a> instruction.</p>
<h2 id="timestamp"><a class="header" href="#timestamp">TIMESTAMP</a></h2>
<p>Original <a href="https://www.evm.codes/#42?fork=shanghai">EVM</a> instruction.</p>
<h2 id="number"><a class="header" href="#number">NUMBER</a></h2>
<p>Original <a href="https://www.evm.codes/#43?fork=shanghai">EVM</a> instruction.</p>
<h2 id="prevrandao"><a class="header" href="#prevrandao">PREVRANDAO</a></h2>
<p>Original <a href="https://www.evm.codes/#44?fork=shanghai">EVM</a> instruction.</p>
<h2 id="difficulty"><a class="header" href="#difficulty">DIFFICULTY</a></h2>
<p>Original <a href="https://www.evm.codes/#44?fork=grayGlacier">EVM</a></p>
<h2 id="gaslimit"><a class="header" href="#gaslimit">GASLIMIT</a></h2>
<p>Original <a href="https://www.evm.codes/#45?fork=shanghai">EVM</a> instruction.</p>
<h2 id="chainid"><a class="header" href="#chainid">CHAINID</a></h2>
<p>Original <a href="https://www.evm.codes/#46?fork=shanghai">EVM</a> instruction.</p>
<h2 id="selfbalance"><a class="header" href="#selfbalance">SELFBALANCE</a></h2>
<p>Original <a href="https://www.evm.codes/#47?fork=shanghai">EVM</a> instruction.</p>
<p>Implemented as <a href="eravm/05-instructions/02-evm/environment#balance">BALANCE</a> with an <a href="eravm/05-instructions/02-evm/environment#address">ADDRESS</a> as its argument.</p>
<h2 id="basefee"><a class="header" href="#basefee">BASEFEE</a></h2>
<p>Original <a href="https://www.evm.codes/#48?fork=shanghai">EVM</a> instruction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="calls"><a class="header" href="#calls">Calls</a></h1>
<p>All EVM call instructions follow a similar handling approach. The call type is encoded at the assembly level, so we will focus on the common workflow and note any differences where they arise.</p>
<p>For more information, see the <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#call-staticcall-delegatecall">ZKsync Era documentation</a>.</p>
<h2 id="call"><a class="header" href="#call">CALL</a></h2>
<p>Original <a href="https://www.evm.codes/#f1?fork=shanghai">EVM</a> instruction.</p>
<p>The code checks whether the call is non-static and whether the Ether value is non-zero. If both conditions are met, the call is redirected to the <a href="eravm/05-instructions/02-evm/../../03-system-contracts.html#ether-value-simulator">MsgValueSimulator</a>.</p>
<ul>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#NearCallDefinition">EraVM instruction: <code>call</code> (near call)</a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#FarCalls">EraVM instruction: <code>far_call</code></a></li>
</ul>
<h2 id="delegatecall"><a class="header" href="#delegatecall">DELEGATECALL</a></h2>
<p>Original <a href="https://www.evm.codes/#f4?fork=shanghai">EVM</a> instruction.</p>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#FarCalls">EraVM instruction: <code>far_call</code></a></p>
<h2 id="staticcall"><a class="header" href="#staticcall">STATICCALL</a></h2>
<p>Original <a href="https://www.evm.codes/#fa?fork=shanghai">EVM</a> instruction.</p>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#FarCalls">EraVM instruction: <code>far_call</code></a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="create"><a class="header" href="#create">CREATE</a></h1>
<p>The EVM CREATE instructions are handled similarly.</p>
<p>For more information, see the <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#create-create2">ZKsync Era documentation</a>.</p>
<h2 id="create-1"><a class="header" href="#create-1">CREATE</a></h2>
<p>Original <a href="https://www.evm.codes/#f0?fork=shanghai">EVM</a> instruction.</p>
<h2 id="create2"><a class="header" href="#create2">CREATE2</a></h2>
<p>Original <a href="https://www.evm.codes/#f5?fork=shanghai">EVM</a> instruction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment"><a class="header" href="#environment">Environment</a></h1>
<p>This information is requested a System Contract called <a href="https://github.com/matter-labs/era-system-contracts/blob/main/contracts/SystemContext.sol">SystemContext</a>.</p>
<p>On how the contract is called, see <a href="eravm/05-instructions/02-evm/../../03-system-contracts.html#environmental-data-storage">the relevant section</a>.</p>
<h2 id="address"><a class="header" href="#address">ADDRESS</a></h2>
<p>Original <a href="https://www.evm.codes/#30?fork=shanghai">EVM</a> instruction.</p>
<p>This value is fetched with a native <a href="https://matter-labs.github.io/eravm-spec/spec.html#ContextDefinitions">EraVM instruction: <code>context.this</code></a>.</p>
<h2 id="balance"><a class="header" href="#balance">BALANCE</a></h2>
<p>Original <a href="https://www.evm.codes/#31?fork=shanghai">EVM</a> instruction.</p>
<h2 id="origin"><a class="header" href="#origin">ORIGIN</a></h2>
<p>Original <a href="https://www.evm.codes/#32?fork=shanghai">EVM</a> instruction.</p>
<h2 id="caller"><a class="header" href="#caller">CALLER</a></h2>
<p>Original <a href="https://www.evm.codes/#33?fork=shanghai">EVM</a> instruction.</p>
<p>This value is fetched with a native <a href="https://matter-labs.github.io/eravm-spec/spec.html#ContextDefinitions">EraVM instruction: <code>context.caller</code></a>.</p>
<h2 id="callvalue"><a class="header" href="#callvalue">CALLVALUE</a></h2>
<p>Original <a href="https://www.evm.codes/#34?fork=shanghai">EVM</a> instruction.</p>
<p>This value is fetched with a native <a href="https://matter-labs.github.io/eravm-spec/spec.html#ContextDefinitions">EraVM instruction: <code>context.get_context_u128</code></a>.</p>
<h2 id="calldataload"><a class="header" href="#calldataload">CALLDATALOAD</a></h2>
<p>Original <a href="https://www.evm.codes/#35?fork=shanghai">EVM</a> instruction.</p>
<p>Calldata is accessed using a generic memory access instruction, but the memory chunk itself references the caller’s heap. A “fat pointer” to the parent contract is passed via ABI through registers.</p>
<h3 id="llvm-ir-20"><a class="header" href="#llvm-ir-20">LLVM IR</a></h3>
<pre><code class="language-llvm">@ptr_calldata = private unnamed_addr global ptr addrspace(3) null                   ; global variable declaration
...
store ptr addrspace(3) %0, ptr @ptr_calldata, align 32                              ; saving the pointer from `r1` to the global variable
...
%calldata_pointer = load ptr addrspace(3), ptr @ptr_calldata, align 32              ; loading the pointer from the global variable to `calldata_pointer`
%calldata_value = load i256, ptr addrspace(3) %calldata_pointer, align 32           ; loading the value from the calldata pointer
</code></pre>
<h3 id="eravm-assembly-10"><a class="header" href="#eravm-assembly-10">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add r1, r0, stack[@ptr_calldata]                                                ; saving the pointer from `r1` to the global variable
...
ptr.add stack[@ptr_calldata], r0, r1                                                ; loading the pointer from the global variable to `r1`
ld      r1, r1                                                                      ; loading the value to `r1`
</code></pre>
<ul>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#PtrAddDefinition">EraVM instruction: <code>ptr.add</code></a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#PointerDefinitions">EraVM fat pointers</a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#MemoryForwarding">EraVM memory forwarding mechanism</a></li>
</ul>
<h2 id="calldatasize"><a class="header" href="#calldatasize">CALLDATASIZE</a></h2>
<p>Original <a href="https://www.evm.codes/#36?fork=shanghai">EVM</a> instruction.</p>
<p>The calldata size is stored in the fat pointer from the parent contract (see <a href="eravm/05-instructions/02-evm/07-environment.html#calldataload">CALLDATALOAD</a>), and it can be extracted using bitwise operations, as demonstrated below.</p>
<h3 id="llvm-ir-21"><a class="header" href="#llvm-ir-21">LLVM IR</a></h3>
<pre><code class="language-llvm">@calldatasize = private unnamed_addr global i256 0                                  ; global variable declaration
...
%abi_pointer_value = ptrtoint ptr addrspace(3) %0 to i256                           ; converting the pointer to an integer
%abi_pointer_value_shifted = lshr i256 %abi_pointer_value, 96                       ; shifting the integer right 96 bits
%abi_length_value = and i256 %abi_pointer_value_shifted, 4294967295                 ; keeping the lowest 32 bits of the integer
store i256 %abi_length_value, ptr @calldatasize, align 32                           ; saving the value to the global variable
</code></pre>
<h3 id="eravm-assembly-11"><a class="header" href="#eravm-assembly-11">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add r1, r0, stack[@ptr_calldata]                                                ; saving the pointer from `r1` to the global variable
shr.s   96, r1, r1                                                                  ; shifting the integer right 96 bits
and     @CPI0_0[0], r1, stack[@calldatasize]                                        ; keeping the lowest 32 bits of the integer, saving the value to the global variable
...
CPI0_0:
    .cell 4294967295
</code></pre>
<ul>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#PtrAddDefinition">EraVM instruction: <code>ptr.add</code></a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#PointerDefinitions">EraVM fat pointers</a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#MemoryForwarding">EraVM memory forwarding mechanism</a></li>
</ul>
<h2 id="calldatacopy"><a class="header" href="#calldatacopy">CALLDATACOPY</a></h2>
<p>Original <a href="https://www.evm.codes/#37?fork=shanghai">EVM</a> instruction.</p>
<p>Unlike on EVM, EraVM employs a simple loop over memory operations on 256-bit values.</p>
<h3 id="llvm-ir-22"><a class="header" href="#llvm-ir-22">LLVM IR</a></h3>
<pre><code class="language-llvm">; loading the pointer from the global variable to `calldata_pointer`
%calldata_pointer = load ptr addrspace(3), ptr @ptr_calldata, align 32
; shifting the pointer by 122 bytes
%calldata_source_pointer = getelementptr i8, ptr addrspace(3) %calldata_pointer, i256 122
; copying 64 bytes from calldata at offset 122 to the heap at offset 128
call void @llvm.memcpy.p1.p3.i256(ptr addrspace(1) align 1 inttoptr (i256 128 to ptr addrspace(1)), ptr addrspace(3) align 1 %calldata_source_pointer, i256 64, i1 false)
</code></pre>
<h3 id="eravm-assembly-12"><a class="header" href="#eravm-assembly-12">EraVM Assembly</a></h3>
<pre><code class="language-asm">.BB0_3:
    shl.s   5, r2, r3           ; shifting the offset by 32
    ptr.add r1, r3, r4          ; adding the offset to the calldata pointer
    ld      r4, r4              ; reading the calldata value
    add     128, r3, r3         ; adding the offset to the heap pointer
    st.1    r3, r4              ; writing the calldata value to the heap
    add     1, r2, r2           ; incrementing the offset
    sub.s!  2, r2, r3           ; checking the bounds
    jump.lt @.BB0_3             ; loop continuation branching
</code></pre>
<ul>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#PtrAddDefinition">EraVM instruction: <code>ptr.add</code></a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#PointerDefinitions">EraVM fat pointers</a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#MemoryForwarding">EraVM memory forwarding mechanism</a></li>
</ul>
<h2 id="codecopy"><a class="header" href="#codecopy">CODECOPY</a></h2>
<p>Original <a href="https://www.evm.codes/#38?fork=shanghai">EVM</a> instruction.</p>
<p>See <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#codecopy">the EraVM docs</a>.</p>
<h2 id="codesize"><a class="header" href="#codesize">CODESIZE</a></h2>
<p>Original <a href="https://www.evm.codes/#39?fork=shanghai">EVM</a> instruction.</p>
<p>See <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#codesize">the EraVM docs</a>.</p>
<h2 id="gasprice"><a class="header" href="#gasprice">GASPRICE</a></h2>
<p>Original <a href="https://www.evm.codes/#3a?fork=shanghai">EVM</a> instruction.</p>
<h2 id="extcodesize"><a class="header" href="#extcodesize">EXTCODESIZE</a></h2>
<p>Original <a href="https://www.evm.codes/#3b?fork=shanghai">EVM</a> instruction.</p>
<h2 id="extcodecopy"><a class="header" href="#extcodecopy">EXTCODECOPY</a></h2>
<p>Original <a href="https://www.evm.codes/#3c?fork=shanghai">EVM</a> instruction.</p>
<p>Not supported. Triggers a compile-time error.</p>
<h2 id="returndatasize"><a class="header" href="#returndatasize">RETURNDATASIZE</a></h2>
<p>Original <a href="https://www.evm.codes/#3d?fork=shanghai">EVM</a> instruction.</p>
<p>Similarly to <a href="eravm/05-instructions/02-evm/07-environment.html#calldatasize">CALLDATASIZE</a>, return data size is read from the fat pointer that the child contract returns. It can also be extracted with bitwise operations.</p>
<h3 id="llvm-ir-23"><a class="header" href="#llvm-ir-23">LLVM IR</a></h3>
<pre><code class="language-llvm">%contract_call_external = tail call { ptr addrspace(3), i1 } @__farcall(i256 0, i256 0, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef)
%contract_call_external_result_abi_data = extractvalue { ptr addrspace(3), i1 } %contract_call_external, 0
%contract_call_memcpy_from_child_pointer_casted = ptrtoint ptr addrspace(3) %contract_call_external_result_abi_data to i256
%contract_call_memcpy_from_child_return_data_size_shifted = lshr i256 %contract_call_memcpy_from_child_pointer_casted, 96
%contract_call_memcpy_from_child_return_data_size_truncated = and i256 %contract_call_memcpy_from_child_return_data_size_shifted, 4294967295
</code></pre>
<h3 id="eravm-assembly-13"><a class="header" href="#eravm-assembly-13">EraVM Assembly</a></h3>
<pre><code class="language-asm">near_call       r0, @__farcall, @DEFAULT_UNWIND                 ; calling a child contract
shr.s   96, r1, r1                                              ; shifting the pointer value right 96 bits
and     @CPI0_1[0], r1, r1                                      ; keeping the lowest 32 bits of the pointer value
...
CPI0_1:
    .cell 4294967295
</code></pre>
<p><a href="https://matter-labs.github.io/eravm-spec/spec.html#NearCallDefinition">EraVM instruction: <code>call</code></a></p>
<h2 id="returndatacopy"><a class="header" href="#returndatacopy">RETURNDATACOPY</a></h2>
<p>Original <a href="https://www.evm.codes/#3e?fork=shanghai">EVM</a> instruction.</p>
<p>Unlike on EVM, EraVM employs a simple loop over memory operations on 256-bit values.</p>
<h3 id="llvm-ir-24"><a class="header" href="#llvm-ir-24">LLVM IR</a></h3>
<pre><code class="language-llvm">; loading the pointer from the global variable to `return_data_pointer`
%return_data_pointer = load ptr addrspace(3), ptr @ptr_return_data, align 32
; shifting the pointer by 122 bytes
%return_data_source_pointer = getelementptr i8, ptr addrspace(3) %return_data_pointer, i256 122
; copying 64 bytes from return data at offset 122 to the heap at offset 128
call void @llvm.memcpy.p1.p3.i256(ptr addrspace(1) align 1 inttoptr (i256 128 to ptr addrspace(1)), ptr addrspace(3) align 1 %return_data_source_pointer, i256 64, i1 false)
</code></pre>
<h3 id="eravm-assembly-14"><a class="header" href="#eravm-assembly-14">EraVM Assembly</a></h3>
<pre><code class="language-asm">.BB0_3:
    shl.s   5, r2, r3           ; shifting the offset by 32
    ptr.add r1, r3, r4          ; adding the offset to the return data pointer
    ld      r4, r4              ; reading the return data value
    add     128, r3, r3         ; adding the offset to the heap pointer
    st.1    r3, r4              ; writing the return data value to the heap
    add     1, r2, r2           ; incrementing the offset
    sub.s!  2, r2, r3           ; checking the bounds
    jump.lt @.BB0_3             ; loop continuation branching
</code></pre>
<ul>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#JumpDefinition">EraVM instruction: <code>jump</code></a></li>
<li><a href="https://matter-labs.github.io/eravm-spec/spec.html#Predication">EraVM instruction predication</a></li>
</ul>
<h2 id="extcodehash"><a class="header" href="#extcodehash">EXTCODEHASH</a></h2>
<p>Original <a href="https://www.evm.codes/#3f?fork=shanghai">EVM</a> instruction.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<h2 id="events"><a class="header" href="#events">Events</a></h2>
<p>The EraVM event instructions operate at a lower level. Each <code>LOG</code>-like instruction is expanded into a loop, with each iteration writing two 256-bit words in the following order:</p>
<ol>
<li>The initializer cell, which describes the number of indexed words (e.g. <code>I</code>) and the size of non-indexed data in bytes (e.g. <code>D</code>).</li>
<li><code>I</code> indexed 32-byte words.</li>
<li><code>D</code> bytes of data.</li>
</ol>
<p>If only one word remains to be written, the second input is zero.</p>
<p>For a detailed reference, see <a href="https://matter-labs.github.io/eravm-spec/spec.html#EventDefinition">EraVM instruction: <code>log.event</code></a></p>
<h2 id="log0---log4"><a class="header" href="#log0---log4">LOG0 - LOG4</a></h2>
<p><a href="https://www.evm.codes/#a0?fork=shanghai">LOG0</a> - <a href="https://www.evm.codes/#a4?fork=shanghai">LOG4</a></p>
<h3 id="system-contract"><a class="header" href="#system-contract">System Contract</a></h3>
<p>This information is requested a System Contract called <a href="https://github.com/code-423n4/2024-03-zksync/blob/main/code/system-contracts/contracts/EventWriter.yul">EventWriter</a>.</p>
<p>On how the contract is called, see <a href="https://docs.zksync.io/zksync-protocol/contracts/system-contracts">the relevant section</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logical"><a class="header" href="#logical">Logical</a></h1>
<h2 id="lt"><a class="header" href="#lt">LT</a></h2>
<p>Original <a href="https://www.evm.codes/#10?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-25"><a class="header" href="#llvm-ir-25">LLVM IR</a></h3>
<pre><code class="language-llvm">%comparison_result = icmp ult i256 %value1, %value2
%comparison_result_extended = zext i1 %comparison_result to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#icmp-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-15"><a class="header" href="#eravm-assembly-15">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
sub!    r1, r2, r1
add     0, r0, r1
add.lt  1, r0, r1
st.1    128, r1
</code></pre>
<h2 id="gt"><a class="header" href="#gt">GT</a></h2>
<p>Original <a href="https://www.evm.codes/#11?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-26"><a class="header" href="#llvm-ir-26">LLVM IR</a></h3>
<pre><code class="language-llvm">%comparison_result = icmp ugt i256 %value1, %value2
%comparison_result_extended = zext i1 %comparison_result to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#icmp-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-16"><a class="header" href="#eravm-assembly-16">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
sub!    r1, r2, r1
add     0, r0, r1
add.gt  1, r0, r1
st.1    128, r1
</code></pre>
<h2 id="slt"><a class="header" href="#slt">SLT</a></h2>
<p>Original <a href="https://www.evm.codes/#12?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-27"><a class="header" href="#llvm-ir-27">LLVM IR</a></h3>
<pre><code class="language-llvm">%comparison_result = icmp slt i256 %value1, %value2
%comparison_result_extended = zext i1 %comparison_result to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#icmp-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-17"><a class="header" href="#eravm-assembly-17">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
add     @CPI0_4[0], r0, r3
sub!    r1, r2, r4
add     r0, r0, r4
add.lt  r3, r0, r4
and     @CPI0_4[0], r2, r2
and     @CPI0_4[0], r1, r1
sub!    r1, r2, r5
add.le  r0, r0, r3
xor     r1, r2, r1
sub.s!  @CPI0_4[0], r1, r1
add     r4, r0, r1
add.eq  r3, r0, r1
sub!    r1, r0, r1
add     0, r0, r1
add.ne  1, r0, r1
st.1    128, r1
</code></pre>
<h2 id="sgt"><a class="header" href="#sgt">SGT</a></h2>
<p>Original <a href="https://www.evm.codes/#13?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-28"><a class="header" href="#llvm-ir-28">LLVM IR</a></h3>
<pre><code class="language-llvm">%comparison_result = icmp sgt i256 %value1, %value2
%comparison_result_extended = zext i1 %comparison_result to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#icmp-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-18"><a class="header" href="#eravm-assembly-18">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
add     @CPI0_4[0], r0, r3
sub!    r1, r2, r4
add     r0, r0, r4
add.gt  r3, r0, r4
and     @CPI0_4[0], r2, r2
and     @CPI0_4[0], r1, r1
sub!    r1, r2, r5
add.ge  r0, r0, r3
xor     r1, r2, r1
sub.s!  @CPI0_4[0], r1, r1
add     r4, r0, r1
add.eq  r3, r0, r1
sub!    r1, r0, r1
add     0, r0, r1
add.ne  1, r0, r1
st.1    128, r1
</code></pre>
<h2 id="eq"><a class="header" href="#eq">EQ</a></h2>
<p>Original <a href="https://www.evm.codes/#14?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-29"><a class="header" href="#llvm-ir-29">LLVM IR</a></h3>
<pre><code class="language-llvm">%comparison_result = icmp eq i256 %value1, %value2
%comparison_result_extended = zext i1 %comparison_result to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#icmp-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-19"><a class="header" href="#eravm-assembly-19">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r0, r1
ptr.add.s       36, r1, r2
ld      r2, r2
ptr.add.s       4, r1, r1
ld      r1, r1
sub!    r1, r2, r1
add     0, r0, r1
add.eq  1, r0, r1
st.1    128, r1
</code></pre>
<h2 id="iszero"><a class="header" href="#iszero">ISZERO</a></h2>
<p>Original <a href="https://www.evm.codes/#15?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-30"><a class="header" href="#llvm-ir-30">LLVM IR</a></h3>
<pre><code class="language-llvm">%comparison_result = icmp eq i256 %value, 0
%comparison_result_extended = zext i1 %comparison_result to i256
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#icmp-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-20"><a class="header" href="#eravm-assembly-20">EraVM Assembly</a></h3>
<pre><code class="language-asm">ptr.add stack[@ptr_calldata], r1, r1
ld      r1, r1
sub!    r1, r0, r1
add     0, r0, r1
add.eq  1, r0, r1
st.1    128, r1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<h2 id="mload"><a class="header" href="#mload">MLOAD</a></h2>
<p>Original <a href="https://www.evm.codes/#51?fork=shanghai">EVM</a> instruction.</p>
<p>Heap memory load operation is modeled with a native EraVM instruction.</p>
<h3 id="llvm-ir-31"><a class="header" href="#llvm-ir-31">LLVM IR</a></h3>
<pre><code class="language-llvm">%value = load i256, ptr addrspace(1) %pointer, align 1
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#load-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-21"><a class="header" href="#eravm-assembly-21">EraVM Assembly</a></h3>
<pre><code class="language-asm">ld.1    r1, r2
</code></pre>
<p>See <a href="https://matter-labs.github.io/eravm-spec/spec.html#LoadDefinition">EraVM instruction: <code>st.1</code></a></p>
<h2 id="mstore"><a class="header" href="#mstore">MSTORE</a></h2>
<p>Original <a href="https://www.evm.codes/#52?fork=shanghai">EVM</a> instruction.</p>
<p>Heap memory load operation is modeled with a native EraVM instruction.</p>
<h3 id="llvm-ir-32"><a class="header" href="#llvm-ir-32">LLVM IR</a></h3>
<pre><code class="language-llvm">store i256 128, ptr addrspace(1) inttoptr (i256 64 to ptr addrspace(1)), align 1
</code></pre>
<p><a href="https://releases.llvm.org/15.0.0/docs/LangRef.html#store-instruction">LLVM IR instruction documentation</a></p>
<h3 id="eravm-assembly-22"><a class="header" href="#eravm-assembly-22">EraVM Assembly</a></h3>
<pre><code class="language-asm">st.1    r1, r2
</code></pre>
<p>See <a href="https://matter-labs.github.io/eravm-spec/spec.html#StoreDefinition">EraVM instruction: <code>st.1</code></a></p>
<h2 id="mstore8"><a class="header" href="#mstore8">MSTORE8</a></h2>
<p>Original <a href="https://www.evm.codes/#53?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-33"><a class="header" href="#llvm-ir-33">LLVM IR</a></h3>
<pre><code class="language-llvm">define void @__mstore8(i256 addrspace(1)* nocapture nofree noundef dereferenceable(32) %addr, i256 %val) #2 {
entry:
  %orig_value = load i256, i256 addrspace(1)* %addr, align 1
  %orig_value_shifted_left = shl i256 %orig_value, 8
  %orig_value_shifted_right = lshr i256 %orig_value_shifted_left, 8
  %byte_value_shifted = shl i256 %val, 248
  %store_result = or i256 %orig_value_shifted_right, %byte_value_shifted
  store i256 %store_result, i256 addrspace(1)* %addr, align 1
  ret void
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="return"><a class="header" href="#return">Return</a></h1>
<h2 id="stop"><a class="header" href="#stop">STOP</a></h2>
<p>Original <a href="https://www.evm.codes/#00?fork=shanghai">EVM</a> instruction.</p>
<p>This instruction is a <a href="eravm/05-instructions/02-evm/11-return.html#return">RETURN</a> with an empty data payload.</p>
<h3 id="llvm-ir-34"><a class="header" href="#llvm-ir-34">LLVM IR</a></h3>
<p>The same as for <a href="eravm/05-instructions/02-evm/11-return.html#return">RETURN</a>.</p>
<h2 id="return-1"><a class="header" href="#return-1">RETURN</a></h2>
<p>Original <a href="https://www.evm.codes/#f3?fork=shanghai">EVM</a> instruction.</p>
<p>This instruction works differently in deploy code. For more information, see <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#return-stop">the ZKsync Era documentation</a>.</p>
<h3 id="llvm-ir-35"><a class="header" href="#llvm-ir-35">LLVM IR</a></h3>
<pre><code class="language-llvm">define void @__return(i256 %0, i256 %1, i256 %2) "noinline-oz" #5 personality i32()* @__personality {
entry:
  %abi = call i256@__aux_pack_abi(i256 %0, i256 %1, i256 %2)
  tail call void @llvm.syncvm.return(i256 %abi)
  unreachable
}
</code></pre>
<h2 id="revert"><a class="header" href="#revert">REVERT</a></h2>
<p>Original <a href="https://www.evm.codes/#fd?fork=shanghai">EVM</a> instruction.</p>
<h3 id="llvm-ir-36"><a class="header" href="#llvm-ir-36">LLVM IR</a></h3>
<pre><code class="language-llvm">define void @__revert(i256 %0, i256 %1, i256 %2) "noinline-oz" #5 personality i32()* @__personality {
entry:
  %abi = call i256@__aux_pack_abi(i256 %0, i256 %1, i256 %2)
  tail call void @llvm.syncvm.revert(i256 %abi)
  unreachable
}
</code></pre>
<h3 id="eravm"><a class="header" href="#eravm">EraVM</a></h3>
<p>See also EraVM instruction <code>revert</code>: <a href="https://matter-labs.github.io/eravm-spec/spec.html#NearRevertDefinition">when returning from near calls</a>
and <a href="https://matter-labs.github.io/eravm-spec/spec.html#FarRevertDefinition">when returning from far calls</a>.</p>
<h2 id="invalid"><a class="header" href="#invalid">INVALID</a></h2>
<p>Original <a href="https://www.evm.codes/#fe?fork=shanghai">EVM</a> instruction.</p>
<p>This instruction is a <a href="eravm/05-instructions/02-evm/11-return.html#revert">REVERT</a> with an empty data payload, but it also burns all available gas.</p>
<h3 id="llvm-ir-37"><a class="header" href="#llvm-ir-37">LLVM IR</a></h3>
<p>The same as for <a href="eravm/05-instructions/02-evm/11-return.html#revert">REVERT</a>.</p>
<h3 id="eravm-1"><a class="header" href="#eravm-1">EraVM</a></h3>
<p>See also EraVM instruction <code>revert</code>: <a href="https://matter-labs.github.io/eravm-spec/spec.html#NearRevertDefinition">when returning from near calls</a>
and <a href="https://matter-labs.github.io/eravm-spec/spec.html#FarRevertDefinition">when returning from far calls</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sha3"><a class="header" href="#sha3">SHA3</a></h1>
<p>Original <a href="https://www.evm.codes/#20?fork=shanghai">EVM instruction</a>.</p>
<h2 id="llvm-ir-38"><a class="header" href="#llvm-ir-38">LLVM IR</a></h2>
<pre><code class="language-llvm">define i256 @__sha3(i8 addrspace(1)* nocapture nofree noundef %0, i256 %1, i1 %throw_at_failure) "noinline-oz" #1 personality i32()* @__personality {
entry:
  %addr_int = ptrtoint i8 addrspace(1)* %0 to i256
  %2 = tail call i256 @llvm.umin.i256(i256 %addr_int, i256 4294967295)
  %3 = tail call i256 @llvm.umin.i256(i256 %1, i256 4294967295)
  %gas_left = tail call i256 @llvm.syncvm.gasleft()
  %4 = tail call i256 @llvm.umin.i256(i256 %gas_left, i256 4294967295)
  %abi_data_input_offset_shifted = shl nuw nsw i256 %2, 64
  %abi_data_input_length_shifted = shl nuw nsw i256 %3, 96
  %abi_data_gas_shifted = shl nuw nsw i256 %4, 192
  %abi_data_offset_and_length = add i256 %abi_data_input_length_shifted, %abi_data_input_offset_shifted
  %abi_data_add_gas = add i256 %abi_data_gas_shifted, %abi_data_offset_and_length
  %abi_data_add_system_call_marker = add i256 %abi_data_add_gas, 904625697166532776746648320380374280103671755200316906558262375061821325312
  %call_external = tail call { i8 addrspace(3)*, i1 } @__staticcall(i256 %abi_data_add_system_call_marker, i256 32784, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef, i256 undef)
  %status_code = extractvalue { i8 addrspace(3)*, i1 } %call_external, 1
  br i1 %status_code, label %success_block, label %failure_block

success_block:
  %abi_data_pointer = extractvalue { i8 addrspace(3)*, i1 } %call_external, 0
  %data_pointer = bitcast i8 addrspace(3)* %abi_data_pointer to i256 addrspace(3)*
  %keccak256_child_data = load i256, i256 addrspace(3)* %data_pointer, align 1
  ret i256 %keccak256_child_data

failure_block:
  br i1 %throw_at_failure, label %throw_block, label %revert_block

revert_block:
  call void @__revert(i256 0, i256 0, i256 0)
  unreachable

throw_block:
  call void @__cxa_throw(i8* noalias nocapture nofree align 32 null, i8* noalias nocapture nofree align 32 undef, i8* noalias nocapture nofree align 32 undef)
  unreachable
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="stack"><a class="header" href="#stack">Stack</a></h1>
<h2 id="pop"><a class="header" href="#pop">POP</a></h2>
<p>Original <a href="https://www.evm.codes/#50?fork=shanghai">EVM</a> instruction.</p>
<p>In Yul, it is only used for marking unused values, and is omitted in LLVM IR.</p>
<pre><code class="language-solidity">pop(staticcall(gas(), address(), 0, 64, 0, 32))
</code></pre>
<p>For EVMLA, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/evmla-translator">EVM Legacy Assembly Translator</a>.</p>
<h2 id="jumpdest"><a class="header" href="#jumpdest">JUMPDEST</a></h2>
<p>Original <a href="https://www.evm.codes/#5b?fork=shanghai">EVM</a> instruction.</p>
<p>Unavailable in Yul.</p>
<p>Ignored in EVMLA. See <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/evmla-translator">EVM Legacy Assembly Translator</a> for more information.</p>
<h2 id="push---push32"><a class="header" href="#push---push32">PUSH - PUSH32</a></h2>
<p>Original <a href="https://www.evm.codes/#5f?fork=shanghai">EVM</a> instructions.</p>
<p>Unavailable in Yul.</p>
<p>For EVMLA, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/evmla-translator">EVM Legacy Assembly Translator</a>.</p>
<h2 id="dup1---dup16"><a class="header" href="#dup1---dup16">DUP1 - DUP16</a></h2>
<p>Original <a href="https://www.evm.codes/#80?fork=shanghai">EVM</a> instructions.</p>
<p>Unavailable in Yul.</p>
<p>For EVMLA, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/evmla-translator">EVM Legacy Assembly Translator</a>.</p>
<h2 id="swap1---swap16"><a class="header" href="#swap1---swap16">SWAP1 - SWAP16</a></h2>
<p>Original <a href="https://www.evm.codes/#90?fork=shanghai">EVM</a> instructions.</p>
<p>Unavailable in Yul.</p>
<p>For EVMLA, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/evmla-translator">EVM Legacy Assembly Translator</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="evm-assembly-auxiliary-instructions"><a class="header" href="#evm-assembly-auxiliary-instructions">EVM Assembly Auxiliary Instructions</a></h1>
<p>These instructions do not have a direct representation in EVM or EraVM instruction sets. Instead, they perform auxiliary operations
required for generating the target bytecode.</p>
<h2 id="push-"><a class="header" href="#push-">PUSH [$]</a></h2>
<p>The same as <a href="eravm/05-instructions/./04-yul.html#datasize">datasize</a>.</p>
<h2 id="push--1"><a class="header" href="#push--1">PUSH #[$]</a></h2>
<p>The same as <a href="eravm/05-instructions/./04-yul.html#dataoffset">dataoffset</a>.</p>
<h2 id="assignimmutable"><a class="header" href="#assignimmutable">ASSIGNIMMUTABLE</a></h2>
<p>The same as <a href="eravm/05-instructions/./04-yul.html#setimmutable">setimmutable</a>.</p>
<p>For more information, see <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#setimmutable-loadimmutable">differences with Ethereum</a>.</p>
<h2 id="pushimmutable"><a class="header" href="#pushimmutable">PUSHIMMUTABLE</a></h2>
<p>The same as <a href="eravm/05-instructions/./04-yul.html#loadimmutable">loadimmutable</a>.</p>
<p>For more information, see <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#setimmutable-loadimmutable">differences with Ethereum</a>.</p>
<h2 id="pushlib"><a class="header" href="#pushlib">PUSHLIB</a></h2>
<p>The same as <a href="eravm/05-instructions/./04-yul.html#linkersymbol">linkersymbol</a>.</p>
<h2 id="pushdeployaddress"><a class="header" href="#pushdeployaddress">PUSHDEPLOYADDRESS</a></h2>
<p>Returns the address the contract is deployed to.</p>
<h2 id="pushsize"><a class="header" href="#pushsize">PUSHSIZE</a></h2>
<p>Can be only found in deploy code. On EVM, returns the total size of the runtime code and constructor arguments.</p>
<p>On EraVM, it is always 0, since EraVM does not operate on runtime code in deploy code.</p>
<h2 id="push-data"><a class="header" href="#push-data">PUSH data</a></h2>
<p>Pushes a data chunk onto the stack. Data chunks are resolved during the processing of input assembly JSON.</p>
<h2 id="push-tag"><a class="header" href="#push-tag">PUSH [tag]</a></h2>
<p>Pushes an EVM Legacy Assembly destination block identifier onto the stack.</p>
<h2 id="tag"><a class="header" href="#tag">Tag</a></h2>
<p>Starts a new EVM Legacy Assembly block. Tags are processed during the translation of EVM Legacy Assembly into EthIR.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="yul-auxiliary-instructions"><a class="header" href="#yul-auxiliary-instructions">Yul Auxiliary Instructions</a></h1>
<p>These instructions do not map directly to EVM or EraVM but instead perform auxiliary operations necessary for generating the target bytecode.</p>
<h2 id="datasize"><a class="header" href="#datasize">datasize</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#datasize-dataoffset-datacopy">Yul</a> auxiliary instruction.</p>
<p>Unlike on EVM, on EraVM this instruction returns only the size of the header part of the calldata sent to the <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/system-contracts#contract-deployer">ContractDeployer</a>.</p>
<p>For more information, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/instructions/evm/create">CREATE</a>.</p>
<h2 id="dataoffset"><a class="header" href="#dataoffset">dataoffset</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#datasize-dataoffset-datacopy">Yul</a> auxiliary instruction.</p>
<p>Unlike on EVM, this instruction does not relate to offsets. Instead, it returns the bytecode hash of the contract referenced by the Yul object identifier.</p>
<p>For more information, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/instructions/evm/create">CREATE</a>.</p>
<h2 id="datacopy"><a class="header" href="#datacopy">datacopy</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#datasize-dataoffset-datacopy">Yul</a> auxiliary instruction.</p>
<p>Unlike on EVM, on EraVM this instruction copies the bytecode hash passed as <a href="eravm/05-instructions/04-yul.html#dataoffset">dataoffset</a> to the destination. Because our compiler translates instructions without analyzing the surrounding context, there is no other way to obtain the bytecode hash within <a href="eravm/05-instructions/04-yul.html#datacopy">datacopy</a>.</p>
<p>For more information, see <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/instructions/evm/create">CREATE</a>.</p>
<h2 id="setimmutable"><a class="header" href="#setimmutable">setimmutable</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#setimmutable-loadimmutable">Yul</a> auxiliary instruction.</p>
<p>Writes immutables to the auxiliary heap.</p>
<p>For more information, see the <a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#setimmutable-loadimmutable">Differences with Ethereum</a>.</p>
<h2 id="loadimmutable"><a class="header" href="#loadimmutable">loadimmutable</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#setimmutable-loadimmutable">Yul</a> auxiliary instruction.</p>
<p>Reads immutables from the <a href="https://docs.zksync.io/zksync-protocol/compiler/specification/system-contracts#simulator-of-immutables">ImmutableSimulator</a> in runtime code, or from temporary values on auxiliary heap in deploy code.</p>
<p>For more information, see the
<a href="https://docs.zksync.io/zksync-protocol/differences/evm-instructions#setimmutable-loadimmutable">Differences with Ethereum</a>.</p>
<h2 id="linkersymbol"><a class="header" href="#linkersymbol">linkersymbol</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#linkersymbol">Yul</a> auxiliary instruction.</p>
<p>Sets the placeholder of a deployable library. The address must be passed to <code>zksolc</code> with the <code>--libraries</code> option,
either in <a href="eravm/05-instructions/../../02-command-line-interface.html#--libraries">compiler</a> or <a href="eravm/05-instructions/../../05-linker.html">linker</a> mode.</p>
<h2 id="memoryguard"><a class="header" href="#memoryguard">memoryguard</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#memoryguard">Yul</a> auxiliary instruction.</p>
<p>It is a Yul optimizer hint ignored by <strong>zksolc</strong>.</p>
<h2 id="verbatim"><a class="header" href="#verbatim">verbatim</a></h2>
<p>Original <a href="https://docs.soliditylang.org/en/latest/yul.html#verbatim">Yul</a> auxiliary instruction.</p>
<p>Unlike on EVM, on EraVM this instruction has nothing to do with insertions of EVM bytecode. Instead, it is used to implement <a href="https://matter-labs.github.io/era-compiler-solidity/latest/06-eravm-extensions.html">ZKsync EraVM Yul Extensions</a>. In order to compile a Yul contract with extensions, both <a href="eravm/05-instructions/../../02-command-line-interface.html#--yul">Yul mode</a> and <a href="eravm/05-instructions/../../02-command-line-interface.html#--enable-eravm-extensions">EraVM extensions</a> must be enabled.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="extensions"><a class="header" href="#extensions">Extensions</a></h1>
<p>EraVM extensions are a set of additional instructions that can be expressed in Solidity and Yul, that can only be compiled to EraVM bytecode.</p>
<p>There are two ways of using EraVM extensions with <em>zksolc</em>:</p>
<ol>
<li><a href="eravm/06-extensions.html#call-simulations">Call simulations</a> in Solidity.</li>
<li><a href="eravm/06-extensions.html#verbatim"><code>verbatim</code></a> function in Yul mode.</li>
</ol>
<h3 id="call-simulations"><a class="header" href="#call-simulations">Call simulations</a></h3>
<p>Since <em>zksolc</em> could only operate on Yul received from <em>solc</em>, it was not possible to add EraVM-specific functionality to Solidity and Yul. Instead, <em>zksolc</em> introduced a hack with external call instructions that would be replaced with EraVM-specific instructions during emitting LLVM IR. In such external call instructions, the address argument denotes the instruction type, whereas the rest of the arguments are used as instruction arguments.</p>
<p>Call simulations are the only way to use EraVM extensions in Solidity.</p>
<h3 id="verbatim-1"><a class="header" href="#verbatim-1"><code>verbatim</code></a></h3>
<p>In Yul mode, there is a special instruction called <code>verbatim</code> that allows emitting EraVM-specific instructions directly from Yul. This instruction is more robust than call simulations, as it allows passing more arguments to the instruction, and it is not affected by the <em>solc</em>'s optimizer. Unfortunately, <code>verbatim</code> is only available in Yul mode and cannot be used in Solidity.</p>
<p>It is recommended to only use <code>verbatim</code> in Yul mode, as it is more robust and less error-prone than call simulations in Solidity.</p>
<h2 id="call-types"><a class="header" href="#call-types">Call Types</a></h2>
<p>In addition to EVM-like <code>call</code>, <code>staticcall</code> and <code>delegatecall</code>, EraVM introduces a few more call types:</p>
<ol>
<li>Mimic call</li>
<li>System call</li>
<li>Raw call</li>
</ol>
<p>Each of the call types above has <a href="eravm/06-extensions.html#mimic-call-by-reference-0xfff9">its by-ref modification</a>, which <a href="eravm/06-extensions.html#active-pointers">allows passing pointers</a> to ABI data instead of data itself.</p>
<h3 id="mimic-call"><a class="header" href="#mimic-call">Mimic Call</a></h3>
<p>Mimic call is a call type that allows the caller to execute a call to a contract, but with the ability to specify the address of the contract that will be used as the caller. This is useful for EraVM System Contracts that need to call other contracts on behalf of the user. Essentially, it is a more complete version of <code>DELEGATECALL</code>.</p>
<p>For a deeper dive into the Mimic Call, visit <a href="https://matter-labs.github.io/eravm-spec/spec.html">the EraVM formal specification</a>.</p>
<h3 id="system-call"><a class="header" href="#system-call">System Call</a></h3>
<p>System call allows passing more arguments to the callee contract using EraVM registers. This is useful for System Contracts that often require auxiliary data that cannot be passed via calldata.</p>
<p>There are also <a href="eravm/06-extensions.html#system-mimic-call-0xfffa">system mimic calls</a>, which are a combination of both, that is auxiliary arguments can be passed via EraVM registers.</p>
<h3 id="raw-call"><a class="header" href="#raw-call">Raw Call</a></h3>
<p>Raw calls are similar to EVM's <code>CALL</code>, <code>STATICCALL</code>, and <code>DELEGATECALL</code>, but they do not encode the ABI data. Instead, the ABI data is passed as an argument to the instruction. This is useful for EraVM System Contracts that need to call other contracts with a specific ABI data that cannot be encoded in the calldata.</p>
<h2 id="active-pointers"><a class="header" href="#active-pointers">Active Pointers</a></h2>
<p>Active pointers are a set of calldata and return data pointers stored in global LLVM IR variables. They are not accessible directly from Yul, but they can be used to forward call and return data between contracts.</p>
<p>The number of active pointers is fixed at 10, and they are numbered from 0 to 9. Some instructions can only use the 0th pointer due to the lack of spare arguments to specify the pointer number. In order to use pointers other than the 0th, use <a href="eravm/06-extensions.html#active-pointer-swap-0xffd9">the swap instruction</a>.</p>
<p>Instructions that use active pointers have a reference to this section.</p>
<h2 id="constant-arrays"><a class="header" href="#constant-arrays">Constant Arrays</a></h2>
<p>Constant arrays are a set of global arrays that can be used to store constant values. They are not accessible directly from Yul, but they can be used to store constant values that are used in multiple places in the contract.</p>
<h1 id="instruction-reference"><a class="header" href="#instruction-reference">Instruction Reference</a></h1>
<p>The sections below have the following structure:</p>
<ol>
<li>EraVM instruction name and substituted address.</li>
<li>Instruction description.</li>
<li>Pseudo-code illustrating the behavior under the hood.</li>
<li>Solidity call simulation usage example.</li>
<li>Yul <code>verbatim</code> usage example.</li>
</ol>
<p>For instance:</p>
<h2 id="example-0xxxxx"><a class="header" href="#example-0xxxxx">Example (0xXXXX)</a></h2>
<p>Executes an EraVM instruction.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">return_value = instruction(arg1, arg2, arg3)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let return_value := call(arg1, 0xXXXX, arg2, arg3, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let return_value := verbatim_3i_1o("instruction", arg1, arg2, arg3)
}
</code></pre>
<p>Full list of instructions:</p>
<ul>
<li>
<p><a href="eravm/06-extensions.html#to-l1-0xffff">To L1 (0xFFFF)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#precompile-0xfffd">Precompile (0xFFFD)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#decommit-0xffdd">Decommit (0xFFDD)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#set-context-value-0xfff3">Set Context Value (0xFFF3)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#set-pubdata-price-0xfff2">Set Pubdata Price (0xFFF2)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#increment-tx-counter-0xfff1">Increment TX Counter (0xFFF1)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#code-source-0xfffe">Code Source (0xFFFE)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#meta-0xfffc">Meta (0xFFFC)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#get-calldata-pointer-0xfff0">Get Calldata Pointer (0xFFF0)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#get-call-flags-0xffef">Get Call Flags (0xFFEF)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#get-return-data-pointer-0xffee">Get Return Data Pointer (0xFFEE)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#get-extra-abi-data-0xffe5">Get Extra ABI Data (0xFFE5)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#multiplication-with-overflow-0xffe6">Multiplication with Overflow (0xFFE6)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#event-initialize-0xffed">Event Initialize (0xFFED)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#event-write-0xffec">Event Write (0xFFEC)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#mimic-call-0xfffb">Mimic Call (0xFFFB)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#mimic-call-by-reference-0xfff9">Mimic Call by Reference (0xFFF9)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#system-mimic-call-0xfffa">System Mimic Call (0xFFFA)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#system-mimic-call-by-reference-0xfff8">System Mimic Call by Reference (0xFFF8)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#raw-call-0xfff7">Raw Call (0xFFF7)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#raw-call-by-reference-0xfff6">Raw Call by Reference (0xFFF6)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#system-call-0xfff5">System Call (0xFFF5)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#system-call-by-reference-0xfff4">System Call by Reference (0xFFF4)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-load-calldata-0xffeb">Active Pointer: Load Calldata (0xFFEB)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-load-return-data-0xffea">Active Pointer: Load Return Data (0xFFEA)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-load-decommit-0xffdc">Active Pointer: Load Decommit (0xFFDC)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-increment-0xffe9">Active Pointer: Increment (0xFFE9)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-shrink-0xffe8">Active Pointer: Shrink (0xFFE8)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-pack-0xffe7">Active Pointer: Pack (0xFFE7)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-load-0xffe4">Active Pointer: Load (0xFFE4)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-copy-0xffe3">Active Pointer: Copy (0xFFE3)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-size-0xffe2">Active Pointer: Size (0xFFE2)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-swap-0xffd9">Active Pointer: Swap (0xFFD9)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-return-0xffdb">Active Pointer: Return (0xFFDB)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#active-pointer-revert-0xffda">Active Pointer: Revert (0xFFDA)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#constant-array-declare-0xffe1">Constant Array: Declare (0xFFE1)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#constant-array-set-0xffe0">Constant Array: Set (0xFFE0)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#constant-array-finalize-0xffdf">Constant Array: Finalize (0xFFDF)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#constant-array-get-0xffde">Constant Array: Get (0xFFDE)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#return-deployed-verbatim-only">Return Deployed (verbatim-only)</a></p>
</li>
<li>
<p><a href="eravm/06-extensions.html#throw-verbatim-only">Throw (verbatim-only)</a></p>
</li>
</ul>
<p>Notes:</p>
<ol>
<li>The <code>input_length</code> parameter is always set to 0xFFFF or non-zero value. It prevents the <em>solc</em>'s optimizer from optimizing the call out.</li>
<li>Instructions that do not modify state are using <code>staticcall</code> instead of <code>call</code>.</li>
<li>Instructions such as raw calls preserve the call type, so they act as modifiers of <code>call</code>, <code>staticcall</code>, and <code>delegatecall</code>.</li>
</ol>
<h2 id="to-l1-0xffff"><a class="header" href="#to-l1-0xffff">To L1 (0xFFFF)</a></h2>
<p>Send a message to L1.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">to_l1(is_first, value_1, value_2)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := call(is_first, 0xFFFF, value_1, value_2, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_3i_0o("to_l1", is_first, value_1, value_2)
}
</code></pre>
<h2 id="precompile-0xfffd"><a class="header" href="#precompile-0xfffd">Precompile (0xFFFD)</a></h2>
<p>Calls an EraVM precompile.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">return_value = precompile(input_data, ergs)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let return_value := staticcall(input_data, 0xFFFD, ergs, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let return_value := verbatim_2i_01("precompile", input_data, ergs)
}
</code></pre>
<h2 id="decommit-0xffdd"><a class="header" href="#decommit-0xffdd">Decommit (0xFFDD)</a></h2>
<p>Calls the EraVM decommit.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">return_value = decommit(versioned_hash, ergs)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let return_value := staticcall(versioned_hash, 0xFFDD, ergs, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let return_value := verbatim_2i_01("decommit", input_data, ergs)
}
</code></pre>
<h2 id="set-context-value-0xfff3"><a class="header" href="#set-context-value-0xfff3">Set Context Value (0xFFF3)</a></h2>
<p>Sets the 128-bit context value. Usually the value is used to pass Ether to the callee contract.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">set_context_value(value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := call(0, 0xFFF3, value, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_1i_0o("set_context_u128", value)
}
</code></pre>
<h2 id="set-pubdata-price-0xfff2"><a class="header" href="#set-pubdata-price-0xfff2">Set Pubdata Price (0xFFF2)</a></h2>
<p>Sets the public data price.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">set_pubdata_price(value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := call(value, 0xFFF2, 0, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_1i_0o("set_pubdata_price", value)
}
</code></pre>
<h2 id="increment-tx-counter-0xfff1"><a class="header" href="#increment-tx-counter-0xfff1">Increment TX Counter (0xFFF1)</a></h2>
<p>Increments the EraVM transaction counter.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">increment_tx_counter()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := call(0, 0xFFF1, 0, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("increment_tx_counter")
}
</code></pre>
<h2 id="code-source-0xfffe"><a class="header" href="#code-source-0xfffe">Code Source (0xFFFE)</a></h2>
<p>Returns the address where the contract is actually deployed, even if it is called with a delegate call. Mostly used in EraVM System Contracts.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">code_source = code_source()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let code_source := staticcall(0, 0xFFFE, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let code_source := verbatim_0i_1o("code_source")
}
</code></pre>
<h2 id="meta-0xfffc"><a class="header" href="#meta-0xfffc">Meta (0xFFFC)</a></h2>
<p>Returns a part of the internal EraVM state.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">meta = meta()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let meta := staticcall(0, 0xFFFC, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let meta := verbatim_0i_1o("meta")
}
</code></pre>
<h2 id="get-calldata-pointer-0xfff0"><a class="header" href="#get-calldata-pointer-0xfff0">Get Calldata Pointer (0xFFF0)</a></h2>
<p>Returns the ABI-encoded calldata pointer as integer.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">pointer = get_calldata_pointer()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let pointer := staticcall(0, 0xFFF0, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let pointer := verbatim_0i_1o("get_global::ptr_calldata")
}
</code></pre>
<h2 id="get-call-flags-0xffef"><a class="header" href="#get-call-flags-0xffef">Get Call Flags (0xFFEF)</a></h2>
<p>Returns the call flags encoded as 256-bit integer.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">flags = get_call_flags()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let flags := staticcall(0, 0xFFEF, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let flags := verbatim_0i_1o("get_global::call_flags")
}
</code></pre>
<h2 id="get-return-data-pointer-0xffee"><a class="header" href="#get-return-data-pointer-0xffee">Get Return Data Pointer (0xFFEE)</a></h2>
<p>Returns the ABI-encoded return data pointer as integer.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">pointer = get_return_data_pointer()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let pointer := staticcall(0, 0xFFEE, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let pointer := verbatim_0i_1o("get_global::ptr_return_data")
}
</code></pre>
<h2 id="get-extra-abi-data-0xffe5"><a class="header" href="#get-extra-abi-data-0xffe5">Get Extra ABI Data (0xFFE5)</a></h2>
<p>Returns the N-th extra ABI data value passed via registers <code>r3</code>-<code>r12</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">value = get_extra_abi_data(index)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let value := staticcall(index, 0xFFE5, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let value := verbatim_0i_1o("get_global::extra_abi_data_0")
    let value := verbatim_0i_1o("get_global::extra_abi_data_1")
    ...
    let value := verbatim_0i_1o("get_global::extra_abi_data_9")
}
</code></pre>
<h2 id="multiplication-with-overflow-0xffe6"><a class="header" href="#multiplication-with-overflow-0xffe6">Multiplication with Overflow (0xFFE6)</a></h2>
<p>Performs a multiplication with overflow, returning the higher register.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">higher_register = mul_high(a, b)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let higher_register := staticcall(a, 0xFFE6, b, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let higher_register := verbatim_2i_1o("mul_high", a, b)
}
</code></pre>
<h2 id="event-initialize-0xffed"><a class="header" href="#event-initialize-0xffed">Event Initialize (0xFFED)</a></h2>
<p>Initializes a new EVM-like event.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">event_initialize(value_1, value_2)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := call(value_1, 0xFFED, value_2, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_2i_0o("event_initialize", value_1, value_2)
}
</code></pre>
<h2 id="event-write-0xffec"><a class="header" href="#event-write-0xffec">Event Write (0xFFEC)</a></h2>
<p>Writes more data to the previously initialized EVM-like event.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">event_write(value_1, value_2)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := call(value_1, 0xFFEC, value_2, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_2i_0o("event_write", value_1, value_2)
}
</code></pre>
<h2 id="mimic-call-0xfffb"><a class="header" href="#mimic-call-0xfffb">Mimic Call (0xFFFB)</a></h2>
<p>Executes an EraVM mimic call.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = mimic_call(callee_address, mimic_address, abi_data)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFFB, 0, abi_data, mimic_address, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_3i_1o("mimic_call", callee_address, mimic_address, abi_data)
}
</code></pre>
<h2 id="mimic-call-by-reference-0xfff9"><a class="header" href="#mimic-call-by-reference-0xfff9">Mimic Call by Reference (0xFFF9)</a></h2>
<p>Executes an EraVM mimic call, passing <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> instead of ABI data.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = mimic_call_byref(callee_address, mimic_address)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFF9, 0, 0, mimic_address, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_2i_1o("mimic_call_byref", callee_address, mimic_address)
}
</code></pre>
<h2 id="system-mimic-call-0xfffa"><a class="header" href="#system-mimic-call-0xfffa">System Mimic Call (0xFFFA)</a></h2>
<p>Executes an EraVM mimic call with additional arguments for System Contracts.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = system_mimic_call(callee_address, mimic_address, abi_data, r3_value, r4_value, [r5_value, r6_value])
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFFA, 0, abi_data, mimic_address, r3_value, r4_value)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_5i_1o("system_mimic_call", callee_address, mimic_address, abi_data, r3_value, r4_value, r5_value, r6_value)
}
</code></pre>
<blockquote>
<p>Yul's <code>verbatim</code> allows passing two more extra arguments as it is no limited by the semantics of the <code>call</code> instruction.</p>
</blockquote>
<h2 id="system-mimic-call-by-reference-0xfff8"><a class="header" href="#system-mimic-call-by-reference-0xfff8">System Mimic Call by Reference (0xFFF8)</a></h2>
<p>Executes an EraVM mimic call with additional arguments for System Contracts, passing <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> instead of ABI data.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = system_mimic_call_byref(callee_address, mimic_address, r3_value, r4_value, [r5_value, r6_value])
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFF8, 0, 0, mimic_address, r3_value, r4_value)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_4i_1o("system_mimic_call_byref", callee_address, mimic_address, r3_value, r4_value, r5_value, r6_value)
}
</code></pre>
<blockquote>
<p>Yul's <code>verbatim</code> allows passing two more extra arguments as it is no limited by the semantics of the <code>call</code> instruction.</p>
</blockquote>
<h2 id="raw-call-0xfff7"><a class="header" href="#raw-call-0xfff7">Raw Call (0xFFF7)</a></h2>
<p>Executes an EraVM raw call.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = raw_call(callee_address, abi_data, output_offset, output_length)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFF7, 0, 0, abi_data, output_offset, output_length)
    let status := staticcall(callee_address, 0xFFF7, 0, abi_data, output_offset, output_length)
    let status := delegatecall(callee_address, 0xFFF7, 0, abi_data, output_offset, output_length)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_4i_1o("raw_call", callee_address, abi_data, output_offset, output_length)
    let status := verbatim_4i_1o("raw_static_call", callee_address, abi_data, output_offset, output_length)
    let status := verbatim_4i_1o("raw_delegate_call", callee_address, abi_data, output_offset, output_length)
}
</code></pre>
<h2 id="raw-call-by-reference-0xfff6"><a class="header" href="#raw-call-by-reference-0xfff6">Raw Call by Reference (0xFFF6)</a></h2>
<p>Executes an EraVM raw call, passing <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> instead of ABI data.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = raw_call_byref(callee_address, output_offset, output_length)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFF7, 0, 0, 0, output_offset, output_length)
    let status := staticcall(callee_address, 0xFFF7, 0, 0, output_offset, output_length)
    let status := delegatecall(callee_address, 0xFFF7, 0, 0, output_offset, output_length)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_3i_1o("raw_call_byref", callee_address, output_offset, output_length)
    let status := verbatim_3i_1o("raw_static_call_byref", callee_address, output_offset, output_length)
    let status := verbatim_3i_1o("raw_delegate_call_byref", callee_address, output_offset, output_length)
}
</code></pre>
<h2 id="system-call-0xfff5"><a class="header" href="#system-call-0xfff5">System Call (0xFFF5)</a></h2>
<p>Executes an EraVM system call.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = system_call(callee_address, r3_value, r4_value, abi_data, r5_value, r6_value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFF5, r3_value, r4_value, abi_data, r5_value, r6_value)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_6i_1o("system_call", callee_address, abi_data, r3_value, r4_value, r5_value, r6_value)
    let status := verbatim_6i_1o("system_static_call", callee_address, abi_data, r3_value, r4_value, r5_value, r6_value)
    let status := verbatim_6i_1o("system_delegate_call", callee_address, abi_data, r3_value, r4_value, r5_value, r6_value)
}
</code></pre>
<blockquote>
<p>Static and delegate system calls are only available in Yul as <code>verbatim</code>.</p>
</blockquote>
<h2 id="system-call-by-reference-0xfff4"><a class="header" href="#system-call-by-reference-0xfff4">System Call by Reference (0xFFF4)</a></h2>
<p>Executes an EraVM system call, passing <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> instead of ABI data.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">status = system_call_byref(callee_address, r3_value, r4_value, r5_value, r6_value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let status := call(callee_address, 0xFFF4, r3_value, r4_value, 0xFFFF, r5_value, r6_value)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let status := verbatim_5i_1o("system_call_byref", callee_address, r3_value, r4_value, r5_value, r6_value)
    let status := verbatim_5i_1o("system_static_call_byref", callee_address, r3_value, r4_value, r5_value, r6_value)
    let status := verbatim_5i_1o("system_delegate_call_byref", callee_address, r3_value, r4_value, r5_value, r6_value)
}
</code></pre>
<blockquote>
<p>Static and delegate system calls are only available in Yul as <code>verbatim</code>.</p>
</blockquote>
<h2 id="active-pointer-load-calldata-0xffeb"><a class="header" href="#active-pointer-load-calldata-0xffeb">Active Pointer: Load Calldata (0xFFEB)</a></h2>
<p>Loads the calldata pointer to <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_load_calldata()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(0, 0xFFEB, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("calldata_ptr_to_active")
}
</code></pre>
<h2 id="active-pointer-load-return-data-0xffea"><a class="header" href="#active-pointer-load-return-data-0xffea">Active Pointer: Load Return Data (0xFFEA)</a></h2>
<p>Loads the return data pointer to <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_load_return_data()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(0, 0xFFEA, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("return_data_ptr_to_active")
}
</code></pre>
<h2 id="active-pointer-load-decommit-0xffdc"><a class="header" href="#active-pointer-load-decommit-0xffdc">Active Pointer: Load Decommit (0xFFDC)</a></h2>
<p>Loads the decommit pointer to <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_load_decommit()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(0, 0xFFDC, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("decommit_ptr_to_active")
}
</code></pre>
<h2 id="active-pointer-increment-0xffe9"><a class="header" href="#active-pointer-increment-0xffe9">Active Pointer: Increment (0xFFE9)</a></h2>
<p>Increments the offset of <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_add(value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(value, 0xFFE9, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_1i_0o("active_ptr_add_assign", value)
}
</code></pre>
<h2 id="active-pointer-shrink-0xffe8"><a class="header" href="#active-pointer-shrink-0xffe8">Active Pointer: Shrink (0xFFE8)</a></h2>
<p>Decrements the slice length of <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_shrink(value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(value, 0xFFE8, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_1i_0o("active_ptr_shrink_assign", value)
}
</code></pre>
<h2 id="active-pointer-pack-0xffe7"><a class="header" href="#active-pointer-pack-0xffe7">Active Pointer: Pack (0xFFE7)</a></h2>
<p>Writes the upper 128 bits to <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_pack(value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(value, 0xFFE7, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_1i_0o("active_ptr_pack_assign", value)
}
</code></pre>
<h2 id="active-pointer-load-0xffe4"><a class="header" href="#active-pointer-load-0xffe4">Active Pointer: Load (0xFFE4)</a></h2>
<p>Loads a value from <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> at the specified offset, similarly to EVM's <code>CALLDATALOAD</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">value = active_ptr_load(offset)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let value := staticcall(offset, 0xFFE4, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let value := verbatim_1i_1o("active_ptr_data_load", offset)
}
</code></pre>
<h2 id="active-pointer-copy-0xffe3"><a class="header" href="#active-pointer-copy-0xffe3">Active Pointer: Copy (0xFFE3)</a></h2>
<p>Copies a slice from the <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> to the heap, similarly to EVM's <code>CALLDATACOPY</code> and <code>RETURNDATACOPY</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_copy(destination, source, size)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(destination, 0xFFE3, source, 0xFFFF, size, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_3i_0o("active_ptr_data_copy", destination, source, size)
}
</code></pre>
<h2 id="active-pointer-size-0xffe2"><a class="header" href="#active-pointer-size-0xffe2">Active Pointer: Size (0xFFE2)</a></h2>
<p>Returns the length of the slice referenced by <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a>, similarly to EVM's <code>CALLDATASIZE</code> and <code>RETURNDATASIZE</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">size = active_ptr_size()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let size := staticcall(0, 0xFFE2, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let size := verbatim_0i_1o("active_ptr_data_size")
}
</code></pre>
<h2 id="active-pointer-swap-0xffd9"><a class="header" href="#active-pointer-swap-0xffd9">Active Pointer: Swap (0xFFD9)</a></h2>
<p>Swaps the Nth and Mth <a href="eravm/06-extensions.html#active-pointers">active pointers</a>. Swapping allows the active pointer instructions to use pointers other than the 0th.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_swap(N, M)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(N, 0xFFD9, M, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_2i_0o("active_ptr_swap", N, M)
}
</code></pre>
<h2 id="active-pointer-return-0xffdb"><a class="header" href="#active-pointer-return-0xffdb">Active Pointer: Return (0xFFDB)</a></h2>
<p>Returns from the contract, using <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> as the return data.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_return()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(0, 0xFFDB, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("active_ptr_return_forward")
}
</code></pre>
<h2 id="active-pointer-revert-0xffda"><a class="header" href="#active-pointer-revert-0xffda">Active Pointer: Revert (0xFFDA)</a></h2>
<p>Reverts from the contract, using <a href="eravm/06-extensions.html#active-pointers">the 0th active pointer</a> as the return data.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">active_ptr_revert()
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(0, 0xFFDA, 0, 0xFFFF, 0, 0)
}
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("active_ptr_revert_forward")
}
</code></pre>
<h2 id="constant-array-declare-0xffe1"><a class="header" href="#constant-array-declare-0xffe1">Constant Array: Declare (0xFFE1)</a></h2>
<p>Declares a new <a href="eravm/06-extensions.html#constant-arrays">global array of constants</a>. After the array is declared, it must be right away filled with values using <a href="eravm/06-extensions.html#constant-array-set-0xffe0">the set instruction</a> and declared final using <a href="eravm/06-extensions.html#constant-array-finalize-0xffdf">the finalization instruction</a>.</p>
<p>Index must be an 8-bit constant value in the range <code>[0; 255]</code>.</p>
<p>Size must be a 16-bit constant value in the range <code>[0; 65535]</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">const_array_declare(index, size)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(index, 0xFFE1, size, 0xFFFF, 0, 0)
}
</code></pre>
<blockquote>
<p>This instruction is not available in Yul as <code>verbatim</code>.</p>
</blockquote>
<h2 id="constant-array-set-0xffe0"><a class="header" href="#constant-array-set-0xffe0">Constant Array: Set (0xFFE0)</a></h2>
<p>Sets a value in a <a href="eravm/06-extensions.html#constant-arrays">global array of constants</a>.</p>
<p>Index must be an 8-bit constant value in the range <code>[0; 255]</code>.</p>
<p>Size must be a 16-bit constant value in the range <code>[0; 65535]</code>.</p>
<p>Value must be a 256-bit constant value.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">const_array_set(index, size, value)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(index, 0xFFE0, size, 0xFFFF, value, 0)
}
</code></pre>
<blockquote>
<p>This instruction is not available in Yul as <code>verbatim</code>.</p>
</blockquote>
<h2 id="constant-array-finalize-0xffdf"><a class="header" href="#constant-array-finalize-0xffdf">Constant Array: Finalize (0xFFDF)</a></h2>
<p>Finalizes a <a href="eravm/06-extensions.html#constant-arrays">global array of constants</a>.</p>
<p>Index must be an 8-bit constant value in the range <code>[0; 255]</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">const_array_finalize(index)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := staticcall(index, 0xFFDF, 0, 0xFFFF, 0, 0)
}
</code></pre>
<blockquote>
<p>This instruction is not available in Yul as <code>verbatim</code>.</p>
</blockquote>
<h2 id="constant-array-get-0xffde"><a class="header" href="#constant-array-get-0xffde">Constant Array: Get (0xFFDE)</a></h2>
<p>Gets a value from a <a href="eravm/06-extensions.html#constant-arrays">global array of constants</a>.</p>
<p>Index must be an 8-bit constant value in the range <code>[0; 255]</code>.</p>
<p>Offset must be a 16-bit constant value in the range <code>[0; 65535]</code>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">value = const_array_get(index, offset)
</code></pre>
<p>Solidity usage:</p>
<pre><code class="language-solidity">assembly {
    let value := staticcall(index, 0xFFDE, offset, 0xFFFF, 0, 0)
}
</code></pre>
<blockquote>
<p>This instruction is not available in Yul as <code>verbatim</code>.</p>
</blockquote>
<h2 id="return-deployed-verbatim-only"><a class="header" href="#return-deployed-verbatim-only">Return Deployed (verbatim-only)</a></h2>
<p>Returns heap data from the constructor.</p>
<p>Since EraVM constructors always return immutables via auxiliary heap, it is not possible to use them for EVM-like scenarios, such as EVM emulators.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">return_deployed(offset, length)
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_2i_0o("return_deployed", offset, length)
}
</code></pre>
<h2 id="throw-verbatim-only"><a class="header" href="#throw-verbatim-only">Throw (verbatim-only)</a></h2>
<p>Throws a <a href="eravm/./03-exception-handling.html#function-level">function-level exception</a>.</p>
<p>For a deeper dive into EraVM exceptions, see <a href="eravm/./03-exception-handling.html">this page</a>.</p>
<p>Pseudo-code:</p>
<pre><code class="language-solidity">throw()
</code></pre>
<p>Yul usage:</p>
<pre><code class="language-solidity">assembly {
    let _ := verbatim_0i_0o("throw")
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="eravm-binary-layout"><a class="header" href="#eravm-binary-layout">EraVM Binary Layout</a></h1>
<p>This page describes how assembler listing looks like and how it is transformed to bytecode that can be deployed to the chain.</p>
<h2 id="definitions"><a class="header" href="#definitions">Definitions</a></h2>
<ul>
<li>A directive is a command issued to the assembler, which is not translated into an executable bytecode instruction.
Their names start with a period, for example, <code>.cell</code>.
Directives are used to regulate the translation process.</li>
<li>An instruction constitutes the smallest executable segment of bytecode.
In EraVM, each instruction is exactly eight bytes long.</li>
<li>A word is a 256-bit unsigned integer in a big-endian format.</li>
</ul>
<h2 id="structure-of-assembly-file"><a class="header" href="#structure-of-assembly-file">Structure of Assembly File</a></h2>
<p>This section describes the structure of an EraVM assembly file, a text file typically with the extension <code>.zasm</code>.</p>
<h3 id="data-types"><a class="header" href="#data-types">Data Types</a></h3>
<ul>
<li><code>U256</code> word, a 256-bit unsigned integer number, big-endian.</li>
<li><code>U16</code> 16-bit unsigned integer number, big-endian.</li>
</ul>
<h3 id="sections"><a class="header" href="#sections">Sections</a></h3>
<p>The source code within an EraVM assembly is organized into several sections. The start of a section is denoted by one of the following directives:</p>
<ul>
<li><code>.rodata</code>: constant, read-only data.</li>
<li><code>.data</code>: global mutable data.</li>
<li><code>.text</code>: executable code.</li>
</ul>
<p>The description of any section may be spread across the file:</p>
<pre><code class="language-asm">.rodata
    .cell 0
.text
    &lt;some instruction&gt;
.rodata
    .cell 1
</code></pre>
<p>In this example, multiple <code>.rodata</code> sections appear, but in the resulting binary file they will be merged into a single contiguous region of memory. The same principle applies to other sections.</p>
<h3 id="defining-data"><a class="header" href="#defining-data">Defining Data</a></h3>
<p>The <code>.cell</code> directive defines data:</p>
<pre><code class="language-asm">.rodata
    .cell -1
    .cell 23090
.data
    .cell 1213
</code></pre>
<p>Notes:</p>
<ul>
<li>Using <code>.cell</code> in the <code>.data</code> section is deprecated and will not be supported in the future versions of assembly.</li>
<li>The value of cell is provided as a signed 256-bit decimal number.</li>
<li>Negative numbers will be encoded as 256-bit 2's complement, e.g. <code>-1</code> is encoded as <code>0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code>.</li>
<li>An optional <code>+</code> sign before positive numbers is allowed, e.g. <code>.cell +123</code>.</li>
<li>Hexadecimal integer literals are not supported.</li>
</ul>
<p>Symbols (label names) are supported, for example:</p>
<pre><code class="language-asm">.text

f:
   add r0, r0, r0

g:
   add r0, r0, r0

.rodata

my_cells:
    .cell @lab1
    .cell @lab2
    .cell -1
</code></pre>
<p>A single <code>@</code> is prefixing the label name.</p>
<p>Each <code>.cell</code> is 256-bit wide, even though an address such as <code>@lab1</code> or <code>@lab2</code> is just 16-bit wide.
Addresses are padded with zeroes to fit in the word.</p>
<h3 id="overall-structure"><a class="header" href="#overall-structure">Overall Structure</a></h3>
<p>The structure of an assembly file is described as follows:</p>
<pre><code class="language-asm">&lt;file&gt; := &lt;section&gt;*

&lt;section&gt; :=
    | ".rodata" &lt;eol&gt;  &lt;const-element&gt;*
    | ".data" &lt;eol&gt; &lt;data-element&gt; *
    | ".text" &lt;eol&gt;  &lt;code-element&gt; *

&lt;const-element&gt; := &lt;label&gt; | &lt;cell&gt;
&lt;label&gt; ::= [a-zA-Z_.@][0-9a-zA-Z_.@]

&lt;data-element&gt; := &lt;label&gt; | &lt;cell&gt;
&lt;cell&gt; :=
    ".cell" &lt;256-bit signed or unsigned constant&gt;

&lt;comment&gt; ::= ";" .*
&lt;labels&gt; ::= (&lt;label&gt; ":" ) *
&lt;code-element&gt; ::= &lt;labels&gt; &lt;instruction&gt; &lt;operand-list&gt; &lt;comment&gt;? EOL
</code></pre>
<ul>
<li><code>EOL</code> stands for “end of line”.</li>
<li><code>&lt;instruction&gt;</code>, <code>&lt;operand-list&gt;</code> depend on the specific instruction.
See the <a href="https://matter-labs.github.io/eravm-spec/spec.html">EraVM specification</a>.</li>
</ul>
<h2 id="execution-model"><a class="header" href="#execution-model">Execution model</a></h2>
<p>This section provides some elements of the execution environment, the Era Virtual Machine.
Full execution model is described in <a href="https://matter-labs.github.io/eravm-spec/spec.html">EraVM specification</a>.</p>
<h3 id="registers"><a class="header" href="#registers">Registers</a></h3>
<p>EraVM has 16 general-purpose registers and 2 special registers:</p>
<ul>
<li><code>PC</code> is a 16-bit program counter register; it holds the address of the next instruction to be executed.</li>
<li><code>SP</code> is a 16-bit stack pointer register. It points to the address following the top of the stack.</li>
</ul>
<h3 id="memory-1"><a class="header" href="#memory-1">Memory</a></h3>
<p>EraVM memory is divided into <strong>pages</strong>. When a contract is launched, EraVM assigns several pages to it:</p>
<ul>
<li>
<p><strong>Code</strong> page.</p>
<ul>
<li>
<p>Immutable.</p>
</li>
<li>
<p>Contains <code>2^{16}</code> words.</p>
</li>
<li>
<p>Used to store both instructions and the constants of type <code>U256</code>.</p>
</li>
<li>
<p>Each word may contain 4 instructions or one constant.</p>
</li>
<li>
<p>Instructions and constants are indistinguishable.</p>
</li>
<li>
<p>Code page is addressable in two ways:</p>
<ul>
<li>
<p>When EraVM fetches instruction from this page using <code>PC</code>, it addresses 8-byte chunks.</p>
</li>
<li>
<p>When EraVM fetches constants from this page, it addresses 32-byte (word-sized) chunks.</p>
<p>For example, reading a constant by the address 0 will yield a word composed of binary
encoded instructions number 0, 1, 2 and 3; reading a constant by
the address 1 from this page will yield a binary encoding for the
instructions number 4,5,6,7, and so on.</p>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Heap</strong> page.</p>
<ul>
<li>Contains <code>2^{32}</code> bytes and is byte-addressable.</li>
<li>However, it is only possible to read words from heap, not the individual
bytes.</li>
</ul>
</li>
<li>
<p><strong>Data stack</strong> page.</p>
<ul>
<li>Contains <code>2^{16}</code> words.</li>
<li>Grows towards higher addresses, so every push-like instruction advances <code>SP</code> by at least one.</li>
<li>Reserving space on stack is therefore incrementing the value of <code>SP</code>.</li>
<li>Each word has an additional tag. If the tag is set, the word contains a
pointer to a heap page, either of this contract or belonging to a different
contract.</li>
<li>Data on stack page can be addressed by their absolute addresses, or relative
to <code>SP</code>.</li>
<li>Global mutable variables are allocated on stack.</li>
</ul>
</li>
</ul>
<h3 id="callstack"><a class="header" href="#callstack">Callstack</a></h3>
<p>EraVM has a separate call stack, a utility data structure that holds information about call frames.
There are two kinds of call frames in the EraVM, corresponding to near and far calls:</p>
<ul>
<li>Far call frame corresponds to a call to a different contract.</li>
<li>Near call frame corresponds to a near call to the code inside the same
contract. Near calls are a low-level mechanism that is used mostly in system
contracts.</li>
</ul>
<p>Call stack differs from the data stack pages, described in section <strong>Memory</strong>.</p>
<h2 id="binary-layout"><a class="header" href="#binary-layout">Binary layout</a></h2>
<p>The binary file published on chain and passed to EraVM has no structure. It is an image loaded at the beginning of the <strong>code</strong> page (with offset 0).</p>
<p>The initial value of <code>PC</code> is zero, therefore the execution will start at the first instruction on the code page.
Instructions or functions in <code>.text</code> section are not reordered, so the first instruction appearing in the assembly file will be executed first, regardless of labels.</p>
<p>The length of the binary should be an odd number of words, that is, <code>32 * (2N+1)</code> bytes.</p>
<p>The last word in the binary file is the metadata hash, see section <strong>Metadata Hash</strong>.</p>
<h2 id="symbols"><a class="header" href="#symbols">Symbols</a></h2>
<p>There are three default predefined symbols:</p>
<ol>
<li><code>DEFAULT_UNWIND</code>: default exception handler / stack unroller for near call instruction <code>call</code>.</li>
<li><code>DEFAULT_FAR_RETURN</code>:  default stack unroller for returns (see <strong>Landing Pads</strong>).</li>
<li><code>DEFAULT_FAR_REVERT</code>:  default stack unroller for reverts (see <strong>Landing Pads</strong>).</li>
</ol>
<p>If the user did not define one of these labels, the assembler will define it and emit a corresponding landing pad (see <strong>Landing Pads</strong>).</p>
<h2 id="linking-and-loading"><a class="header" href="#linking-and-loading">Linking and loading</a></h2>
<p>This section details how the assembly file structure is flattened into a loadable image.</p>
<p>The binary file is divided into three regions:</p>
<ol>
<li>Initializer.</li>
<li>Instructions.</li>
<li>Constant pool.</li>
</ol>
<p>The following subsections describe these regions.</p>
<h3 id="initializer-region"><a class="header" href="#initializer-region">Initializer region</a></h3>
<p>Mutable global variables are allocated in the beginning of the stack page, not in code.
The stack page supports absolute addressing, therefore the global variables can be accessed directly by their addresses.</p>
<p>If the assembly file defines global variables, the assembler will emit a special initializer code in the beginning of the program; otherwise, initializer region is skipped and we pass to the code region immediately.</p>
<p>The first instruction of the initializer region is <code>incsp &lt;number of globals&gt;</code>. It allocates one word on a data stack per global mutable variable.</p>
<p>For each global that is initialized with a non-zero value, assembler does the following:</p>
<ul>
<li>Copies its initializer to <code>.rodata</code>, which will be loaded to the code page.</li>
<li>Emits an instruction:</li>
</ul>
<pre><code class="language-asm">add code[INIT], r0, stack[IDX]
</code></pre>
<p>where:</p>
<ul>
<li><code>INIT</code> is the address of the initializer in the <code>.rodata</code>.</li>
<li><code>IDX</code>  is the index of the global variable.</li>
</ul>
<p>For example, the following program:</p>
<pre><code class="language-asm">.text

some_label:
  sub!   r0, r0, r0
  jump @some_label

.data
    my_globals:
    .cell 32

.rodata
    .cell 0
</code></pre>
<p>Will be translated as if it were written this way:</p>
<pre><code class="language-asm">.text
init_globals:
    incsp 1
    add code[@global_init_0], r0, stack[0]

some_label:
    sub! r0, r0, r0
    jump @some_label

.rodata
    .cell 0
    global_init_0:
    .cell 32
</code></pre>
<h3 id="code-region"><a class="header" href="#code-region">Code region</a></h3>
<p>The <code>.text</code> section is emitted after the initializer region or, if there are no globals, right in the start of the binary file.
It is followed by the landing pads and the padding, before the start of the constant pool region.</p>
<h4 id="landing-pads"><a class="header" href="#landing-pads">Landing Pads</a></h4>
<p>After emitting the instructions provided in the <code>.text</code> section of the assembly file, the assembler may emit the landing pads for near calls, returns and reverts.
This happens for three predefined symbols: <code>DEFAULT_UNWIND</code>, <code>DEFAULT_FAR_RETURN</code> and <code>DEFAULT_FAR_REVERT</code>.</p>
<p>For example, if the symbol <code>DEFAULT_FAR_RETURN</code> is not explicitly defined, it will be defined automatically and the following landing pad will be appended to the executable code:</p>
<pre><code class="language-asm">;; landing pad for returns
DEFAULT_FAR_RETURN:
    retl @DEFAULT_FAR_RETURN
</code></pre>
<p>If the contract executes an instruction <code>retl @DEFAULT_FAR_RETURN</code>, the control is passed to the address <code>DEFAULT_FAR_RETURN</code>, which hosts the same instruction.
This starts a loop, popping all near call frames from the callstack. The last <code>retl</code> will perform a far return from the contract.
This allows emitting <code>retl @DEFAULT_FAR_RETURN</code> to return from any place inside the contract, no matter how many near calls are currently active.</p>
<p>If neither of the predefined symbols <code>DEFAULT_UNWIND</code>, <code>DEFAULT_FAR_RETURN</code>, <code>DEFAULT_FAR_REVERT</code> was defined explicitly, the following code will be emitted after the <code>.text</code> section.</p>
<pre><code class="language-asm">;; landing pad for near calls
DEFAULT_UNWIND:
    ret.panic.to_label r0, @DEFAULT_UNWIND

;; landing pad for returns
DEFAULT_FAR_RETURN:
    ret.ok.to_label r1, @DEFAULT_FAR_RETURN

;; landing pad for reverts
DEFAULT_FAR_REVERT:
    ret.revert.to_label r1, @DEFAULT_FAR_REVERT
</code></pre>
<h4 id="code-padding"><a class="header" href="#code-padding">Code padding</a></h4>
<p>The code section starts at 0, if we count the initializing code as its part. Therefore, it is aligned on a 32 byte boundary.
If the total number of instructions, with the landing pads, is not divisible by <code>4</code>, the assembler emits 1 to 3 <code>INVALID</code> instructions as a padding.
This way, the instructions will fill a certain number of words completely, and the following region (constant pool region) is aligned on a 32-byte boundary as well.</p>
<h3 id="constant-pool-region"><a class="header" href="#constant-pool-region">Constant pool region</a></h3>
<p>The constant pool region is aligned on a <code>32</code> byte boundary.
It is placed immediately after the code region and contains:</p>
<ul>
<li>Constants defined in <code>.rodata</code> section.</li>
<li>Initializers for mutable globals.</li>
<li>Padding: nothing or a zero-word to ensure, that the total length of the binary file, including the following hash, equals to an odd number of words.</li>
<li>Optionally, <strong>metadata hash</strong>.</li>
</ul>
<h3 id="metadata-hash"><a class="header" href="#metadata-hash">Metadata Hash</a></h3>
<p>An optional, implementation-defined hash of the contract metadata, which may include its source.
Depending on the initial layer where the compilation starts (a Solidity contract, its Yul code, assembly), the hash value may be different.</p>
<ul>
<li><a href="eravm/../02-command-line-interface.html#--metadata">Metadata usage and definition.</a></li>
<li><a href="eravm/../02-command-line-interface.html#--metadata-hash">Supported metadata hash types.</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-zksync-compiler-with-sanitizers"><a class="header" href="#building-zksync-compiler-with-sanitizers">Building ZKsync compiler with sanitizers</a></h1>
<p>This is a guide on how to build the ZKsync Solidity compiler with sanitizers enabled.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Sanitizers are tools that help find bugs in code. They are used to detect memory corruption, leaks, and undefined behavior.
The most common sanitizers are <code>AddressSanitizer</code>, <code>MemorySanitizer</code>, and <code>ThreadSanitizer</code>.</p>
<p>If you are not familiar with sanitizers, see the <a href="https://rustc-dev-guide.rust-lang.org/sanitizers.html">official documentation</a>.</p>
<h3 id="who-is-this-guide-for"><a class="header" href="#who-is-this-guide-for">Who is this guide for?</a></h3>
<p>This guide is for developers who want to debug issues with ZKsync compilers.</p>
<h3 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h3>
<ul>
<li><a href="https://www.rust-lang.org/tools/install">Rust and Cargo</a></li>
<li><a href="https://git-scm.com/downloads">Git</a></li>
<li><a href="https://llvm.org/docs/GettingStarted.html">LLVM compiler</a></li>
</ul>
<div class="warning">
For sanitizers build to work, the host LLVM compiler version that is used to build LLVM <b>MUST</b>
have the same version as the LLVM compiler that is used internally by `rustc` to build the ZKsync compiler.
<p>You can check the LLVM version used by <code>rustc</code> by running the following command <code>rustc --version --verbose</code>.</p>
</div>
<h2 id="build-steps"><a class="header" href="#build-steps">Build steps</a></h2>
<p>The general steps to have a sanitizer enabled build include:</p>
<ol>
<li>Build the LLVM framework with the required sanitizer enabled.</li>
<li>Build <code>zksolc</code> with the LLVM build from the previous step.</li>
</ol>
<p>Please, follow the common <a href="guides/../01-installation.html#building-from-source">installation instructions</a>
until the <code>zksync-llvm build</code> step.</p>
<p>This guide assumes the build with <code>AddressSanitizer</code> enabled.</p>
<h3 id="build-llvm-with-sanitizer-enabled"><a class="header" href="#build-llvm-with-sanitizer-enabled">Build LLVM with sanitizer enabled</a></h3>
<p>When building LLVM, use <code>--sanitizer &lt;sanitizer&gt;</code> option and set build type to <code>RelWithDebInfo</code>:</p>
<pre><code class="language-shell">zksync-llvm build --sanitizer=Address --build-type=RelWithDebInfo
</code></pre>
<div class="warning">
Please note that the default Apple Clang compiler is not compatible with Rust.
You need to install LLVM using Homebrew and specify the path to the LLVM compiler in the `--extra-args` option.
For example:
</div>
<pre><code class="language-shell">zksync-llvm build --sanitizer=Address \
  --extra-args '\-DCMAKE_C_COMPILER=/opt/homebrew/opt/llvm/bin/clang' \
               '\-DCMAKE_CXX_COMPILER=/opt/homebrew/opt/llvm/bin/clang++'
</code></pre>
<h3 id="build-zksolc-with-sanitizer-enabled"><a class="header" href="#build-zksolc-with-sanitizer-enabled">Build zksolc with sanitizer enabled</a></h3>
<p>To build the ZKsync compiler with sanitizer enabled, you need to set the <code>RUSTFLAGS</code> environment variable
to <code>-Z sanitizer=address</code> and run the <code>cargo build</code> command.
Sanitizers build is the feature that is available only for the nightly Rust compiler, it is recommended
to set <code>RUSTC_BOOTSTRAP=1</code> environment variable before the build.</p>
<p>It is also mandatory to use <code>--target</code> option to specify the target architecture. Otherwise, the build will fail.
Please, check the table below to find the correct target for your platform.</p>
<div class="table-wrapper"><table><thead><tr><th>Platform</th><th>LLVM Target Triple</th></tr></thead><tbody>
<tr><td>Linux arm64</td><td><code>aarch64-unknown-linux-gnu</code></td></tr>
<tr><td>Linux x86</td><td><code>x86_64-unknown-linux-gnu</code></td></tr>
<tr><td>macOS arm64</td><td><code>aarch64-apple-darwin</code></td></tr>
<tr><td>macOS x86</td><td><code>x86_64-apple-darwin</code></td></tr>
</tbody></table>
</div>
<p>Additionally, for proper reports symbolization it is recommended to set the <code>ASAN_SYMBOLIZER_PATH</code> environment variable.
For more info, see <a href="https://clang.llvm.org/docs/AddressSanitizer.html#id4">symbolizing reports</a> section of LLVM documentation.</p>
<p>For example, to build the ZKsync compiler for macOS arm64 with <code>AddressSanitizer</code> enabled, run the following command:</p>
<pre><code class="language-shell">export RUSTC_BOOTSTRAP=1
export ASAN_SYMBOLIZER_PATH=$(which llvm-symbolizer) # check the path to llvm-symbolizer
TARGET=aarch64-apple-darwin # Change to your target
RUSTFLAGS="-Z sanitizer=address" cargo test --target=${TARGET}
</code></pre>
<p>Congratulations! You have successfully built the ZKsync compiler with sanitizers enabled.</p>
<p>Please, refer to the <a href="https://rustc-dev-guide.rust-lang.org/sanitizers.html">official documentation</a>
for more information on how to use sanitizers and their types.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->
        <script src="js/version-box.js"></script>

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
