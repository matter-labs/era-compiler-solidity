{"language":"Yul","sources":{"EventWriter.yul":{"content":"/**\n * @author Matter Labs\n * @custom:security-contact security@matterlabs.dev\n * @notice The contract responsible for decoding and writing events using low-level instructions.\n * @dev The metadata and topics are passed via registers, and the first accessible register contains their number.\n * The rest of the data is passed via calldata without copying.\n */\nobject \"EventWriter\" {\n    code {\n        return(0, 0)\n    }\n    object \"EventWriter_deployed\" {\n        code {\n            ////////////////////////////////////////////////////////////////\n            //                      HELPER FUNCTIONS\n            ////////////////////////////////////////////////////////////////\n            \n            // For the documentation of the helper functions, please refer to \n            // the corresponding functions in the SystemContractHelper.sol.\n\n            /// @notice Returns the 0-th extraAbiParam for the current call.\n            /// @dev It is equal to the value of the 2-th register at the start of the call.\n            function getExtraAbiData_0() -> extraAbiData {\n                extraAbiData := verbatim_0i_1o(\"get_global::extra_abi_data_0\")\n            }\n\n            /// @notice Returns the 1-th extraAbiParam for the current call.\n            /// @dev It is equal to the value of the 3-th register at the start of the call.\n            function getExtraAbiData_1() -> extraAbiData {\n                extraAbiData := verbatim_0i_1o(\"get_global::extra_abi_data_1\")\n            }\n\n            /// @notice Returns the 2-th extraAbiParam for the current call.\n            /// @dev It is equal to the value of the 4-th register at the start of the call.\n            function getExtraAbiData_2() -> extraAbiData {\n                extraAbiData := verbatim_0i_1o(\"get_global::extra_abi_data_2\")\n            }\n\n            /// @notice Returns the 3-th extraAbiParam for the current call.\n            /// @dev It is equal to the value of the 5-th register at the start of the call.\n            function getExtraAbiData_3() -> extraAbiData {\n                extraAbiData := verbatim_0i_1o(\"get_global::extra_abi_data_3\")\n            }\n\n            /// @notice Returns the 4-th extraAbiParam for the current call.\n            /// @dev It is equal to the value of the 6-th register at the start of the call.\n            function getExtraAbiData_4() -> extraAbiData {\n                extraAbiData := verbatim_0i_1o(\"get_global::extra_abi_data_4\")\n            }\n\n            /// @notice Returns the call flags for the current call.\n            /// @dev Call flags is the value of the first register at the start of the call.\n            /// @dev The zero bit of the callFlags indicates whether the call is\n            /// a constructor call. The first bit of the callFlags indicates whether\n            /// the call is a system one.\n            function getCallFlags() -> ret {\n                ret := verbatim_0i_1o(\"get_global::call_flags\")\n            }\n\n            /// @notice Initialize a new event\n            /// @param initializer The event initializing value\n            /// @param value1 The first topic or data chunk.\n            function eventInitialize(initializer, value1) {\n                verbatim_2i_0o(\"event_initialize\", initializer, value1)\n            }\n\n            /// @notice Continue writing the previously initialized event.\n            /// @param value1 The first topic or data chunk.\n            /// @param value2 The second topic or data chunk.\n            function eventWrite(value1, value2) {\n                verbatim_2i_0o(\"event_write\", value1, value2)\n            }\n            \n            // @dev Write 1-th topic and first data chunk\n            function writeFirstTopicWithDataChunk() {\n                let topic1 := getExtraAbiData_1()\n                let dataChunk := calldataload(0)\n                eventWrite(topic1, dataChunk)\n            }\n\n            // @dev Write 1-th and 2-th event topics \n            function writeFirstTwoTopics() {\n                let topic1 := getExtraAbiData_1()\n                let topic2 := getExtraAbiData_2()\n                eventWrite(topic1, topic2)\n            }\n\n            // @dev Write 3-th topic and first data chunk\n            function writeThirdTopicWithDataChunk() {\n                let topic3 := getExtraAbiData_3()\n                let dataChunk := calldataload(0)\n                eventWrite(topic3, dataChunk)\n            }\n\n            // @dev Write 3-th and 4-th event topics \n            function writeSecondTwoTopics() {\n                let topic3 := getExtraAbiData_3()\n                let topic4 := getExtraAbiData_4()\n                eventWrite(topic3, topic4)\n            }\n\n            // @dev Reverts the call if a caller hasn't set the \"isSystem\" flag before calling\n            // Note: this method is different from the `onlySystemCall` modifier that is used in system contracts.\n            function onlySystemCall() {\n                let callFlags := getCallFlags()\n                let isSystemCall := and(callFlags, 2)\n\n                if iszero(isSystemCall) {\n                    revert(0, 0)\n                }\n            }\n\n            ////////////////////////////////////////////////////////////////\n            //                      FALLBACK\n            ////////////////////////////////////////////////////////////////\n            \n            // Ensure that contract is called on purpose\n            onlySystemCall()\n\n            let numberOfTopics := getExtraAbiData_0()\n            // Only 4 indexed fields are allowed, same as on EVM\n            if gt(numberOfTopics, 4) {\n                revert(0, 0)\n            }\n            \n            let dataLength := calldatasize()\n            // Increment number of topics to include the `msg.sender` as a topic\n            let initializer := add(shl(32, dataLength), add(numberOfTopics, 1))\n            eventInitialize(initializer, caller())\n\n            // Save the pointer to written data\n            let dataCursor\n\n            // Handle every case separately, to save gas on loops (alternative approach)\n            switch numberOfTopics\n                case 0 {\n                    // Nothing to publish\n                }\n                case 1 {\n                    writeFirstTopicWithDataChunk()\n                    dataCursor := add(dataCursor, 0x20)\n                }\n                case 2 {\n                    writeFirstTwoTopics()\n                }\n                case 3 { \n                    writeFirstTwoTopics()\n                    writeThirdTopicWithDataChunk()\n                    dataCursor := add(dataCursor, 0x20)\n                }\n                case 4 { \n                    writeFirstTwoTopics()\n                    writeSecondTwoTopics()\n                }\n                default {\n                    // Unreachable\n                    revert(0, 0)\n                }\n\n            // Write all the event data, two words at a time\n            for {} lt(dataCursor, dataLength) {\n                dataCursor := add(dataCursor, 0x40)\n            } {\n                let chunk1 := calldataload(dataCursor)\n                let chunk2 := calldataload(add(dataCursor, 0x20))\n                eventWrite(chunk1, chunk2)\n            }\n        }\n    }\n}\n"}},"settings":{"optimizer":{"enabled":true,"mode":"3","details":null,"fallbackToOptimizingForSize":false,"disableSystemRequestMemoization":true},"outputSelection":{"*":{"":["metadata"],"*":["abi","evm.methodIdentifiers"]}},"libraries":{},"isSystem":false,"forceEvmla":false,"areLibrariesMissing":false}}